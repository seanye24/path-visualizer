{"version":3,"sources":["images/map.svg","images/algorithm.svg","images/creativity.svg","images/weight.svg","images/start.svg","images/end.svg","services/GridConstants.js","components/Square.js","services/Algorithms.js","services/Animations.js","components/Grid.js","components/Select.js","services/Maze.js","components/TopBar.js","components/Legend.js","components/Tutorial.js","components/App.js","index.js"],"names":["module","exports","WIDTH","HEIGHT","SIZE","INITIAL_START","INITIAL_END","INITIAL_GRID","getRow","getCol","getCoor","getSq","dist","validMove","validMazeMove","React","memo","props","id","className","onMouseEnter","onMouseDown","onMouseUp","onKeyDown","onKeyUp","tabIndex","GridConstants","DEFAULT_SQ","START_SQ","END_SQ","WALL_SQ","WEIGHT_SQ","VISITED_SQ","VISITED_WEIGHT_SQ","VISITED_HEAD_SQ","VISITED_FINISHED_SQ","VISITED_FINISHED_WEIGHT_SQ","PATH_SQ","PATH_WEIGHT_SQ","PATH_HEAD_SQ","PATH_FINISHED_SQ","PATH_FINISHED_WEIGHT_SQ","update","width","height","Math","floor","Array","fill","sq","row","col","start","end","abs","endRow","endCol","grid","findIndex","prev","visited","weights","Number","MAX_SAFE_INTEGER","pq","currSquare","shift","push","moves","map","move","filter","nextSquare","moveWeight","includes","splice","indexOf","inserted","i","length","path","unshift","heuristic","count","stack","pop","queue","clearAnimate","setGrid","nextGrid","animate","algorithm","speed","a","Promise","resolve","isAnimating","isAnimatingFinished","pathDelay","visitedDelay","Algorithms","square","tick","prevSquare","changeSquare","squareType","ind","wait","ms","setTimeout","delay","document","getElementById","gridStyle","startIsCovering","setStartIsCovering","endIsCovering","setEndIsCovering","isTutorialShowing","useState","mouseIsDownOn","setMouseIsDownOn","isHoldingStart","setIsHoldingStart","isHoldingEnd","setIsHoldingEnd","isWDown","setIsWDown","mouseIsOver","setMouseIsOver","useEffect","oldGrid","startSq","s","endSq","Animations","useCallback","e","key","style","sqType","renderSquare","Select","customSelectStyle","menu","provided","state","backgroundColor","border","margin","padding","menuList","borderRadius","container","display","alignItems","control","menuIsOpen","boxShadow","fontFamily","fontWeight","fontSize","cursor","userSelect","color","hasValue","dropdownIndicator","indicatorSeparator","placeholder","option","singleValue","whiteSpace","overflow","textOverflow","paddingRight","maxWidth","lineHeight","top","valueContainer","styles","options","value","label","optionsMap","onChange","data","isSearchable","tabSelectsValue","generateMaze","maze","resetGrid","finished","randomMaze","promise","dfs","recursiveDivision","kruskal","prim","drawMazeBorder","topRow","bottomRow","leftCol","rightCol","generateWallGrid","getRandomElement","array","random","shuffleArray","newArray","getClosestEmptyTileFrom","from","reduce","closest","idx","closestDist","generateStartEndPosition","idealStart","idealEnd","Set","nextMove","nextMoves","has","add","divide","rowRange","colRange","possibleRows","possibleRowHoles","possibleCols","possibleColHoles","randomRow","drawRow","randomColHole","randomHole","randomCol","drawCol","treeSet","wallMap","iRow","iCol","Object","entries","wall","sq1","sq2","union","forEach","neighborSquares","neighborWalls","t","r","b","l","visitedSquares","visitedWalls","randomWall","TopBar","setIsAnimating","setIsAnimatingFinished","setAlgorithm","setMaze","setSpeed","handleAlgorithmSubmit","event","preventDefault","handleMazeSubmit","Maze","algorithmsMap","dijkstra","astar","greedy","bfs","mazesMap","speedMap","slow","medium","fast","alg","keys","onClick","Legend","name","img","src","alt","draggable","Tutorial","textIndex","setTextIndex","prevButtonStyle","setPrevButtonStyle","nextButtonStyle","setNextButtonStyle","shouldShowAlgorithms","setShouldShowAlgorithms","shouldShowSiteOptions","setShouldShowSiteOptions","shouldShowMapLogo","setShouldShowMapLogo","shouldShowAlgorithmLogo","setShouldShowAlgorithmLogo","shouldShowCreativityLogo","setShouldShowCreativityLogo","tutorialTextContainerRef","useRef","texts","setTutorialPage","current","scrollTop","shouldShow","ref","mapLogo","algorithmLogo","creativityLogo","text","elem","String","fromCharCode","setShouldShow","App","setIsTutorialShowing","updateDimensions","window","addEventListener","removeEventListener","topBarHeight","getElementsByClassName","offsetHeight","legendsHeight","innerWidth","innerHeight","legends","weight","gridTemplateColumns","gridTemplateRows","legend","ReactDOM","render"],"mappings":"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","file":"static/js/main.0e6b3f81.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/map.197c485d.svg\";","module.exports = __webpack_public_path__ + \"static/media/algorithm.6820b192.svg\";","module.exports = __webpack_public_path__ + \"static/media/creativity.5a071791.svg\";","module.exports = __webpack_public_path__ + \"static/media/weight.f8a5f7dd.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.ff2b9671.svg\";","module.exports = __webpack_public_path__ + \"static/media/end.93326d55.svg\";","let GridConstants = {};\nlet WIDTH,\n  HEIGHT,\n  SIZE,\n  INITIAL_START,\n  INITIAL_END,\n  INITIAL_GRID,\n  getRow,\n  getCol,\n  getCoor,\n  getSq,\n  dist,\n  validMove,\n  validMazeMove;\n\nGridConstants.DEFAULT_SQ = 'square';\nGridConstants.START_SQ = 'startSquare';\nGridConstants.END_SQ = 'endSquare';\nGridConstants.WALL_SQ = 'wallSquare';\nGridConstants.WEIGHT_SQ = 'weightSquare';\nGridConstants.VISITED_SQ = 'visitedSquare';\nGridConstants.VISITED_WEIGHT_SQ = 'visitedWeightSquare';\nGridConstants.VISITED_HEAD_SQ = 'visitedHeadSquare';\nGridConstants.VISITED_FINISHED_SQ = 'visitedFinishedSquare';\nGridConstants.VISITED_FINISHED_WEIGHT_SQ = 'visitedFinishedWeightSquare';\nGridConstants.PATH_SQ = 'pathSquare';\nGridConstants.PATH_WEIGHT_SQ = 'pathWeightSquare';\nGridConstants.PATH_HEAD_SQ = 'pathHeadSquare';\nGridConstants.PATH_FINISHED_SQ = 'pathFinishedSquare';\nGridConstants.PATH_FINISHED_WEIGHT_SQ = 'pathFinishedWeightSquare';\n\nconst update = (width, height) => {\n  WIDTH = width;\n  HEIGHT = height;\n\n  // maintain odd number of rows and cols for maze\n  if (WIDTH % 2 === 0) {\n    WIDTH--;\n  }\n  if (HEIGHT % 2 === 0) {\n    HEIGHT--;\n  }\n  SIZE = WIDTH * HEIGHT;\n  INITIAL_START = (Math.floor(HEIGHT / 2)) * WIDTH + Math.floor(WIDTH / 6);\n  INITIAL_END =\n    (Math.floor(HEIGHT / 2)) * WIDTH + Math.floor((WIDTH * 5) / 6);\n  INITIAL_GRID = new Array(SIZE).fill(GridConstants.DEFAULT_SQ);\n  INITIAL_GRID[INITIAL_START] = GridConstants.START_SQ;\n  INITIAL_GRID[INITIAL_END] = GridConstants.END_SQ;\n\n  getRow = (sq) => Math.floor(sq / WIDTH);\n\n  getCol = (sq) => sq % WIDTH;\n\n  getCoor = (sq) => [getRow(sq), getCol(sq)];\n\n  getSq = (row, col) => row * WIDTH + col;\n\n  dist = (start, end) =>\n    Math.abs(getRow(start) - getRow(end)) +\n    Math.abs(getCol(start) - getCol(end));\n\n  validMove = (start, end) =>\n    end < SIZE && end >= 0 && Math.abs(getCol(end) - getCol(start)) <= 2;\n\n  validMazeMove = (start, end) => {\n    const [endRow, endCol] = getCoor(end);\n    return (\n      endRow >= 1 &&\n      endRow < HEIGHT - 1 &&\n      endCol >= 1 &&\n      endCol < WIDTH - 1 &&\n      validMove(start, end)\n    );\n  };\n\n  GridConstants.WIDTH = WIDTH;\n  GridConstants.HEIGHT = HEIGHT;\n  GridConstants.SIZE = SIZE;\n  GridConstants.INITIAL_START = INITIAL_START;\n  GridConstants.INITIAL_END = INITIAL_END;\n  GridConstants.INITIAL_GRID = INITIAL_GRID;\n  GridConstants.getRow = getRow;\n  GridConstants.getCol = getCol;\n  GridConstants.getCoor = getCoor;\n  GridConstants.getSq = getSq;\n  GridConstants.dist = dist;\n  GridConstants.validMove = validMove;\n  GridConstants.validMazeMove = validMazeMove;\n  GridConstants.update = update;\n};\n\nupdate(0, 0);\n\nexport default GridConstants;\n","import React from 'react';\nimport './../styles/Square.css';\n\nconst Square = (props) => {\n  return (\n    <div\n      id={props.id}\n      className={props.className}\n      onMouseEnter={() => props.onMouseEnter(props.id)}\n      onMouseDown={() => props.onMouseDown(props.id)}\n      onMouseUp={() => props.onMouseUp(props.id)}\n      onKeyDown={props.onKeyDown}\n      onKeyUp={props.onKeyUp}\n      tabIndex={-1}\n    ></div>\n  );\n};\n\nexport default React.memo(Square);\n","import GridConstants from './../services/GridConstants.js';\n\nconst dijkstra = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (moveWeight < weights[pq[i]]) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  while (currSquare || currSquare === 0) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst astar = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const heuristic = (start, end) => {\n    return (\n      Math.abs(\n        Math.floor(start / GridConstants.WIDTH) -\n          Math.floor(end / GridConstants.WIDTH)\n      ) + Math.abs((start % GridConstants.WIDTH) - (end % GridConstants.WIDTH))\n    );\n  };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (\n              moveWeight + heuristic(nextSquare, end) <\n              weights[pq[i]] + heuristic(pq[i], end)\n            ) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  let path = [];\n  let currSquare = end;\n  while (currSquare || currSquare === 0) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n\n  return [visited, path];\n};\n\nconst greedy = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = { start: 1 };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = GridConstants.dist(nextSquare, end);\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      }\n\n      // insert into priority queue\n      if (!pq.includes(nextSquare) && !visited.includes(nextSquare)) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n        let inserted = false;\n        for (let i = 0; i < pq.length; i++) {\n          if (moveWeight < weights[pq[i]]) {\n            pq.splice(i, 0, nextSquare);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          pq.push(nextSquare);\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare || currSquare === 0) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst dfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const stack = [start];\n  while (stack.length > 0) {\n    const currSquare = stack.pop();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into stack\n      if (!visited.includes(nextSquare) && !stack.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        stack.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare || currSquare === 0) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst bfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const queue = [start];\n  while (queue.length > 0) {\n    const currSquare = queue.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into queue\n      if (!visited.includes(nextSquare) && !queue.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        queue.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare || currSquare === 0) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nexport default { dijkstra, astar, greedy, dfs, bfs };\n","import GridConstants from './../services/GridConstants.js';\nimport Algorithms from './Algorithms';\n\nconst clearAnimate = (grid, setGrid) => {\n  const nextGrid = grid.map((sq) => {\n    if (\n      sq === GridConstants.START_SQ ||\n      sq === GridConstants.END_SQ ||\n      sq === GridConstants.WALL_SQ\n    ) {\n      return sq;\n    } else if (\n      sq === GridConstants.WEIGHT_SQ ||\n      sq === GridConstants.VISITED_WEIGHT_SQ ||\n      sq === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n      sq === GridConstants.PATH_WEIGHT_SQ ||\n      sq === GridConstants.PATH_FINISHED_WEIGHT_SQ\n    ) {\n      return GridConstants.WEIGHT_SQ;\n    } else {\n      return GridConstants.DEFAULT_SQ;\n    }\n  });\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst animate = async (algorithm, grid, setGrid, speed) => {\n  if (!algorithm || !speed) {\n    return Promise.resolve({ isAnimating: false, isAnimatingFinished: false });\n  }\n\n  let pathDelay = 30;\n  let visitedDelay;\n  switch (speed) {\n    case 'none':\n      break;\n    case 'slow':\n      visitedDelay = 50;\n      break;\n    case 'medium':\n      visitedDelay = 30;\n      break;\n    case 'fast':\n      visitedDelay = 10;\n      break;\n    default:\n  }\n\n  grid = clearAnimate(grid, setGrid);\n  let visited, path;\n  switch (algorithm) {\n    case 'dijkstra':\n      [visited, path] = Algorithms.dijkstra(grid);\n      break;\n    case 'astar':\n      [visited, path] = Algorithms.astar(grid);\n      break;\n    case 'greedy':\n      [visited, path] = Algorithms.greedy(grid);\n      break;\n    case 'dfs':\n      [visited, path] = Algorithms.dfs(grid);\n      break;\n    case 'bfs':\n      [visited, path] = Algorithms.bfs(grid);\n      break;\n    default:\n  }\n\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n  visited = visited.filter((square) => square !== start && square !== end);\n  path = path.filter((square) => square !== start && square !== end);\n\n  // animate visited\n  let tick = 0;\n  let prevSquare = null;\n  for (const square of visited) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.sq,\n          prevSquare.squareType,\n          (tick += visitedDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_WEIGHT_SQ\n          : GridConstants.VISITED_SQ;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        square,\n        GridConstants.VISITED_HEAD_SQ,\n        tick\n      );\n      prevSquare = { sq: square, squareType: squareType };\n    } else {\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          : GridConstants.VISITED_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n  if (prevSquare) {\n    grid = changeSquare(\n      grid,\n      setGrid,\n      prevSquare.sq,\n      prevSquare.squareType,\n      (tick += visitedDelay)\n    );\n  }\n\n  // animate path\n  prevSquare = null;\n  for (const square of path) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += pathDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_WEIGHT_SQ\n          ? GridConstants.PATH_WEIGHT_SQ\n          : GridConstants.PATH_SQ;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        square,\n        GridConstants.PATH_HEAD_SQ,\n        tick\n      );\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          ? GridConstants.PATH_FINISHED_WEIGHT_SQ\n          : GridConstants.PATH_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.PATH_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n    }\n  }\n  if (speed !== 'none') {\n    await wait(tick);\n  }\n  setGrid(grid);\n  return Promise.resolve({ isAnimating: false, isAnimatingFinished: true });\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst changeSquare = (\n  grid,\n  setGrid,\n  square,\n  squareType,\n  delay,\n) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      document.getElementById(square).className = squareType;\n    }, delay);\n  }\n  return nextGrid;\n};\n\nexport default { animate };\n","import React, { useState, useEffect, useCallback } from 'react';\nimport Square from './Square.js';\nimport Animations from './../services/Animations.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/Grid.css';\n\nconst Grid = ({\n  grid,\n  gridStyle,\n  setGrid,\n  startIsCovering,\n  setStartIsCovering,\n  endIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  isAnimatingFinished,\n  algorithm,\n  isTutorialShowing,\n}) => {\n  const [mouseIsDownOn, setMouseIsDownOn] = useState(null);\n  const [isHoldingStart, setIsHoldingStart] = useState(false);\n  const [isHoldingEnd, setIsHoldingEnd] = useState(false);\n  const [isWDown, setIsWDown] = useState(false);\n  const [mouseIsOver, setMouseIsOver] = useState(null);\n\n  useEffect(() => {\n    const updateGridOnMouseEnter = (sq) => {\n      if (!isAnimating && mouseIsDownOn !== null) {\n        setGrid((oldGrid) => {\n          const nextGrid = [...oldGrid];\n          const startSq = oldGrid.findIndex(\n            (s) => s === GridConstants.START_SQ\n          );\n          const endSq = oldGrid.findIndex((s) => s === GridConstants.END_SQ);\n          if (sq !== startSq && sq !== endSq) {\n            if (isHoldingStart) {\n              document.getElementById(startSq).className = startIsCovering;\n              document.getElementById(sq).className = GridConstants.START_SQ;\n              nextGrid[startSq] = startIsCovering;\n              nextGrid[sq] = GridConstants.START_SQ;\n              if (oldGrid[sq] !== GridConstants.START_SQ) {\n                setStartIsCovering(oldGrid[sq]);\n              }\n              if (isAnimatingFinished) {\n                Animations.animate(algorithm, nextGrid, setGrid, 'none');\n                return;\n              }\n            } else if (isHoldingEnd) {\n              document.getElementById(endSq).className = endIsCovering;\n              document.getElementById(sq).className = GridConstants.END_SQ;\n              nextGrid[endSq] = endIsCovering;\n              nextGrid[sq] = GridConstants.END_SQ;\n              if (oldGrid[sq] !== GridConstants.END_SQ) {\n                setEndIsCovering(oldGrid[sq]);\n              }\n              if (isAnimatingFinished) {\n                Animations.animate(algorithm, nextGrid, setGrid, 'none');\n                return;\n              }\n            } else if (oldGrid[sq] === GridConstants.WEIGHT_SQ) {\n              if (isWDown) {\n                document.getElementById(sq).className =\n                  GridConstants.DEFAULT_SQ;\n                nextGrid[sq] = GridConstants.DEFAULT_SQ;\n              } else {\n                document.getElementById(sq).className = GridConstants.WALL_SQ;\n                nextGrid[sq] = GridConstants.WALL_SQ;\n              }\n            } else if (oldGrid[sq] === GridConstants.WALL_SQ) {\n              if (isWDown) {\n                document.getElementById(sq).className = GridConstants.WEIGHT_SQ;\n                nextGrid[sq] = GridConstants.WEIGHT_SQ;\n              } else {\n                document.getElementById(sq).className =\n                  GridConstants.DEFAULT_SQ;\n                nextGrid[sq] = GridConstants.DEFAULT_SQ;\n              }\n            } else {\n              if (isWDown) {\n                document.getElementById(sq).className = GridConstants.WEIGHT_SQ;\n                nextGrid[sq] = GridConstants.WEIGHT_SQ;\n              } else {\n                document.getElementById(sq).className = GridConstants.WALL_SQ;\n                nextGrid[sq] = GridConstants.WALL_SQ;\n              }\n            }\n          }\n          return nextGrid;\n        });\n      }\n    };\n    updateGridOnMouseEnter(mouseIsOver);\n  }, [\n    mouseIsOver,\n    mouseIsDownOn,\n    isWDown,\n    isHoldingStart,\n    isHoldingEnd,\n    isAnimating,\n    isAnimatingFinished,\n    algorithm,\n    startIsCovering,\n    endIsCovering,\n    setGrid,\n    setMouseIsOver,\n    setStartIsCovering,\n    setEndIsCovering,\n  ]);\n\n  useEffect(() => {\n    if (grid[mouseIsDownOn] === GridConstants.START_SQ) {\n      setIsHoldingStart(true);\n    } else if (grid[mouseIsDownOn] === GridConstants.END_SQ) {\n      setIsHoldingEnd(true);\n    }\n  }, [mouseIsDownOn, grid, setIsHoldingStart, setIsHoldingEnd]);\n\n  const onMouseEnter = useCallback(\n    (sq) => {\n      if (!isTutorialShowing) {\n        setMouseIsOver(sq);\n      }\n    },\n    [isTutorialShowing]\n  );\n\n  const onMouseDown = useCallback(\n    (sq) => {\n      if (!isTutorialShowing) {\n        setMouseIsOver(sq);\n        setMouseIsDownOn(sq);\n      }\n    },\n    [isTutorialShowing]\n  );\n\n  const onMouseUp = useCallback(\n    (sq) => {\n      if (!isTutorialShowing) {\n        setIsHoldingStart(false);\n        setIsHoldingEnd(false);\n        setMouseIsDownOn(null);\n      }\n    },\n    [isTutorialShowing]\n  );\n\n  const onKeyDown = useCallback(\n    (e) => {\n      if (e.key === 'w' && !isTutorialShowing) {\n        setIsWDown(true);\n      }\n    },\n    [isTutorialShowing]\n  );\n\n  const onKeyUp = useCallback(\n    (e) => {\n      if (e.key === 'w' && !isTutorialShowing) {\n        setIsWDown(false);\n      }\n    },\n    [isTutorialShowing]\n  );\n\n  const renderSquare = (sq) => {\n    return (\n      <Square\n        id={sq}\n        key={sq}\n        className={grid[sq]}\n        onMouseEnter={onMouseEnter}\n        onMouseDown={onMouseDown}\n        onMouseUp={onMouseUp}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n      />\n    );\n  };\n\n  const renderGrid = () => {\n    return grid.map((sqType, sq) => renderSquare(sq));\n  };\n\n  return (\n    <div style={gridStyle} className='grid'>\n      {renderGrid()}\n    </div>\n  );\n};\n\nexport default React.memo(Grid);\n","import React from 'react';\nimport ReactSelect from 'react-select';\nimport './../styles/TopBar.css';\n\nconst Select = (props) => {\n  const customSelectStyle = {\n    menu: (provided, state) => ({\n      ...provided,\n      backgroundColor: 'rgb(17, 138, 178)',\n      width: '160px',\n      border: 'none',\n      margin: '0px',\n      padding: '0px',\n    }),\n    menuList: (provided, state) => ({\n      ...provided,\n      padding: '0px',\n      borderRadius: '0px 0px 5px 5px',\n    }),\n    container: (provided, state) => ({\n      ...provided,\n      height: '40px',\n      margin: 'auto 10px',\n      display: 'flex',\n      alignItems: 'center',\n    }),\n    control: (provided, state) => ({\n      ...provided,\n      width: '160px',\n      height: '100%',\n      border: 'none',\n      borderRadius: state.menuIsOpen ? '5px 5px 0px 0px' : '5px',\n      boxShadow: 'none',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n      fontSize: '20px',\n      cursor: 'pointer',\n      userSelect: 'none',\n\n      color: 'white',\n      backgroundColor:\n        state.hasValue || state.menuIsOpen\n          ? 'rgb(17, 138, 178)'\n          : 'transparent',\n      '&:hover': {\n        backgroundColor: 'rgb(17, 138, 178)',\n        color: 'white',\n        border: 'none',\n      },\n    }),\n    dropdownIndicator: (provided, state) => ({\n      margin: '3px',\n    }),\n    indicatorSeparator: (provided) => ({}),\n    placeholder: (provided, state) => ({}),\n    option: (provided, state) => ({\n      ...provided,\n      cursor: 'pointer',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n\n      color: 'white',\n      backgroundColor: 'rgb(17, 138, 178)',\n      '&:hover': {\n        color: 'rgb(38, 70, 83)',\n        backgroundColor: 'rgb(233, 196, 106)',\n      },\n    }),\n    singleValue: (provided) => ({\n      ...provided,\n      whiteSpace: 'nowrap',\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      paddingRight: '4px',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n      lineHeight: '36px',\n      top: '50%',\n      color: '',\n    }),\n    valueContainer: (provided) => ({\n      ...provided,\n      height: '100%',\n    }),\n  };\n\n  return (\n    <ReactSelect\n      styles={customSelectStyle}\n      options={props.options.map((option) => ({\n        value: option,\n        label: props.optionsMap[option],\n      }))}\n      value={\n        props.option && {\n          value: props.option,\n          label: props.optionsMap[props.option],\n        }\n      }\n      onChange={(data) => props.onChange(data.value)}\n      // onInputChange={(data) => props.onChange(data)}\n      placeholder={props.placeholder}\n      isSearchable={false}\n      tabSelectsValue={false}\n    />\n  );\n};\n\nexport default Select;\n","import GridConstants from './../services/GridConstants.js';\n\nconst generateMaze = async (maze, grid, setGrid, resetGrid, speed) => {\n  if (!maze) {\n    return Promise.resolve({ finished: false, grid: grid });\n  }\n  grid = new Array(GridConstants.SIZE).fill(GridConstants.DEFAULT_SQ);\n  setGrid(grid);\n\n  let delay = 5;\n  let promise;\n  switch (maze) {\n    case 'random':\n      promise = await randomMaze(grid, setGrid, 0, delay);\n      break;\n    case 'dfs':\n      promise = await dfs(grid, setGrid, 0, delay);\n      break;\n    case 'recursiveDivision':\n      promise = await recursiveDivision(grid, setGrid, 0, delay);\n      break;\n    case 'kruskal':\n      promise =  await kruskal(grid, setGrid, 0, delay);\n      break;\n    case 'prim':\n      promise =  await prim(grid, setGrid, 0, delay);\n      break;\n    default:\n  }\n  setGrid(promise.grid);\n  return promise;\n};\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      document.getElementById(square).className = squareType;\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst drawRow = (grid, setGrid, tick, delay, row, colRange) => {\n  for (let i = colRange[0]; i <= colRange[1]; i++, tick += delay) {\n    const sq = row * GridConstants.WIDTH + i;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawCol = (grid, setGrid, tick, delay, col, rowRange) => {\n  for (let i = rowRange[0]; i <= rowRange[1]; i++, tick += delay) {\n    const sq = i * GridConstants.WIDTH + col;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawMazeBorder = (grid, setGrid, tick, delay) => {\n  for (let i = 0; i < GridConstants.WIDTH; i++, tick += delay) {\n    const topRow = GridConstants.getSq(0, i);\n    const bottomRow = GridConstants.getSq(GridConstants.HEIGHT - 1, i);\n    grid = changeSquare(grid, setGrid, topRow, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, bottomRow, GridConstants.WALL_SQ, tick);\n  }\n  for (let i = 0; i < GridConstants.HEIGHT; i++, tick += delay) {\n    const leftCol = GridConstants.getSq(i, 0);\n    const rightCol = GridConstants.getSq(i, GridConstants.WIDTH - 1);\n    grid = changeSquare(grid, setGrid, leftCol, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, rightCol, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst generateWallGrid = (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let row = 1; row < GridConstants.HEIGHT - 1; row++) {\n    for (let col = 1; col < GridConstants.WIDTH - 1; col++) {\n      if (!(row % 2 && col % 2)) {\n        grid[GridConstants.getSq(row, col)] = GridConstants.WALL_SQ;\n      }\n    }\n  }\n  setTimeout(() => {\n    setGrid(grid);\n  }, tick);\n  return [tick, [...grid]];\n};\n\nconst getRandomNumberBetween = (start, end) => {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n};\n\nconst getRandomElement = (array) => {\n  return array.splice(getRandomNumberBetween(0, array.length - 1), 1)[0];\n};\n\nconst shuffleArray = (array) => {\n  const newArray = [];\n  while (array.length > 0) {\n    newArray.push(getRandomElement(array));\n  }\n  return newArray;\n};\n\nconst getClosestEmptyTileFrom = (grid, from) => {\n  return grid.reduce((closest, sq, idx) => {\n    if (sq === GridConstants.DEFAULT_SQ) {\n      if (closest === -1) {\n        return idx;\n      } else {\n        const closestDist = GridConstants.dist(from, closest);\n        const sqDist = GridConstants.dist(from, idx);\n        return sqDist < closestDist ? idx : closest;\n      }\n    } else {\n      return closest;\n    }\n  }, -1);\n};\n\nconst generateStartEndPosition = (\n  grid,\n  setGrid,\n  idealStart,\n  idealEnd,\n  delay\n) => {\n  const start = getClosestEmptyTileFrom(grid, idealStart);\n  const end = getClosestEmptyTileFrom(grid, idealEnd);\n  grid = changeSquare(grid, setGrid, start, GridConstants.START_SQ, delay);\n  return changeSquare(grid, setGrid, end, GridConstants.END_SQ, delay);\n};\n\nconst randomMaze = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let i = 0; i < grid.length; i++) {\n    if (GridConstants.validMazeMove(i, i) && Math.random() < 0.35) {\n      grid[i] = GridConstants.WALL_SQ;\n    }\n  }\n  setTimeout(() => setGrid(grid), tick);\n\n  grid = [...grid];\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(0, 0),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst dfs = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  const start = GridConstants.getSq(1, 1);\n  const visited = new Set([start]);\n  const path = [start];\n  while (path.length > 0) {\n    const currSquare = path.pop();\n    let moves = [-2, 2, -2 * GridConstants.WIDTH, 2 * GridConstants.WIDTH];\n    moves = moves.filter((move) =>\n      GridConstants.validMazeMove(currSquare, currSquare + move)\n    );\n\n    while (moves.length > 0) {\n      const nextMove =\n        currSquare + moves.splice(Math.random() * moves.length, 1)[0];\n      const nextMoves = [(currSquare + nextMove) / 2, nextMove];\n      if (!visited.has(nextMove)) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[0],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[1],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        visited.add(nextMove);\n        path.push(nextMove);\n        path.push(nextMove);\n        break;\n      }\n    }\n  }\n\n  // place end as far away as possible from start\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst recursiveDivision = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n\n  [tick, grid] = divide(\n    grid,\n    setGrid,\n    tick,\n    delay,\n    [0, GridConstants.HEIGHT - 1],\n    [0, GridConstants.WIDTH - 1]\n  );\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst divide = (grid, setGrid, tick, delay, rowRange, colRange) => {\n  const [possibleRows, possibleRowHoles] = [[], []];\n  const [possibleCols, possibleColHoles] = [[], []];\n  for (let i = rowRange[0] + 1; i < rowRange[1]; i++) {\n    if ((i - rowRange[0]) % 2 === 0) {\n      possibleRows.push(i);\n    } else {\n      possibleRowHoles.push(i);\n    }\n  }\n  for (let i = colRange[0] + 1; i < colRange[1]; i++) {\n    if ((i - colRange[0]) % 2 === 0) {\n      possibleCols.push(i);\n    } else {\n      possibleColHoles.push(i);\n    }\n  }\n\n  if (possibleRows.length === 0 || possibleCols.length === 0) {\n    return [tick, grid];\n  } else {\n    if (possibleRows.length >= possibleCols.length) {\n      const randomRow = getRandomElement(possibleRows);\n      [tick, grid] = drawRow(grid, setGrid, tick, delay, randomRow, colRange);\n      const randomColHole = getRandomElement(possibleColHoles);\n      const randomHole = randomRow * GridConstants.WIDTH + randomColHole;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [rowRange[0], randomRow],\n        colRange\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [randomRow, rowRange[1]],\n        colRange\n      );\n    } else {\n      let randomCol = getRandomElement(possibleCols);\n      [tick, grid] = drawCol(grid, setGrid, tick, delay, randomCol, rowRange);\n      const randomRowHole = getRandomElement(possibleRowHoles);\n      const randomHole = randomRowHole * GridConstants.WIDTH + randomCol;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        colRange[0],\n        randomCol,\n      ]);\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        randomCol,\n        colRange[1],\n      ]);\n    }\n    return [tick, grid];\n  }\n};\n\nconst kruskal = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let treeSet = {};\n  let wallMap = {};\n\n  // fill wallMap and treeSet\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    const [iRow, iCol] = GridConstants.getCoor(i);\n    if (GridConstants.validMazeMove(i, i)) {\n      if (iRow % 2 && iCol % 2) {\n        treeSet[i] = new Set([i]);\n      } else {\n        if (iCol % 2) {\n          wallMap[i] = [i - GridConstants.WIDTH, i + GridConstants.WIDTH];\n        } else if (iRow % 2) {\n          wallMap[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  for (const [wall, [sq1, sq2]] of shuffleArray(Object.entries(wallMap))) {\n    if (!treeSet[sq1].has(sq2)) {\n      grid = changeSquare(\n        grid,\n        setGrid,\n        wall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      const union = new Set([...treeSet[sq1], ...treeSet[sq2]]);\n      treeSet[sq1].forEach((sq) => (treeSet[sq] = union));\n      treeSet[sq2].forEach((sq) => (treeSet[sq] = union));\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst prim = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let neighborSquares = {};\n  let neighborWalls = {};\n\n  // fill walls\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    if (GridConstants.validMazeMove(i, i)) {\n      const [iRow, iCol] = GridConstants.getCoor(i);\n      if (iRow % 2 && iCol % 2) {\n        const t = GridConstants.validMazeMove(i, i - GridConstants.WIDTH)\n          ? [i - GridConstants.WIDTH]\n          : [];\n        const r = GridConstants.validMazeMove(i, i + 1) ? [i + 1] : [];\n        const b = GridConstants.validMazeMove(i, i + GridConstants.WIDTH)\n          ? [i + GridConstants.WIDTH]\n          : [];\n        const l = GridConstants.validMazeMove(i, i - 1) ? [i - 1] : [];\n        neighborWalls[i] = [...t, ...r, ...b, ...l];\n      } else if (iRow % 2 ^ iCol % 2) {\n        if (iCol % 2) {\n          neighborSquares[i] = [\n            i - GridConstants.WIDTH,\n            i + GridConstants.WIDTH,\n          ];\n        } else if (iRow % 2) {\n          neighborSquares[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  const visitedSquares = new Set([GridConstants.getSq(1, 1)]);\n  let visitedWalls = [...neighborWalls[GridConstants.getSq(1, 1)]];\n  while (visitedWalls.length > 0) {\n    const randomWall = getRandomElement(visitedWalls);\n    const [sq1, sq2] = neighborSquares[randomWall];\n    if (sq1 > GridConstants.SIZE || sq2 > GridConstants.SIZE) {\n    }\n    if (visitedSquares.has(sq1) ^ visitedSquares.has(sq2)) {\n      if (!visitedSquares.has(sq1)) {\n        visitedSquares.add(sq1);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq1]];\n      } else {\n        visitedSquares.add(sq2);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq2]];\n      }\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomWall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nexport default { generateMaze };\n","import React from 'react';\nimport Select from './Select';\nimport Animations from './../services/Animations.js';\nimport Maze from './../services/Maze.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/TopBar.css';\n\nconst TopBar = ({\n  grid,\n  setGrid,\n  resetGrid,\n  setStartIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  setIsAnimating,\n  setIsAnimatingFinished,\n  algorithm,\n  setAlgorithm,\n  maze,\n  setMaze,\n  speed,\n  setSpeed,\n  isTutorialShowing,\n}) => {\n  const handleAlgorithmSubmit = async (event) => {\n    event.preventDefault();\n    if (!isAnimating && !isTutorialShowing) {\n      setIsAnimating(true);\n      const promise = await Animations.animate(algorithm, grid, setGrid, speed);\n      setIsAnimating(promise.isAnimating);\n      setIsAnimatingFinished(promise.isAnimatingFinished);\n    }\n  };\n\n  const handleMazeSubmit = async (maze) => {\n    if (!isAnimating && !isTutorialShowing) {\n      setIsAnimating(true);\n      const promise = await Maze.generateMaze(maze, grid, setGrid, resetGrid);\n      setMaze(null);\n      setStartIsCovering(GridConstants.DEFAULT_SQ);\n      setEndIsCovering(GridConstants.DEFAULT_SQ);\n      setIsAnimating(promise.finished);\n      setIsAnimatingFinished(false);\n    }\n  };\n\n  const onAlgorithmChange = (alg) => {\n    setAlgorithm(alg);\n  };\n\n  const onMazeChange = (maze) => {\n    setMaze(maze);\n    handleMazeSubmit(maze);\n  };\n\n  const onSpeedChange = (speed) => {\n    setSpeed(speed);\n  };\n\n  const handleResetClick = (e) => {\n    if (!isAnimating && !isTutorialShowing) {\n      e.preventDefault();\n      resetGrid();\n    }\n  };\n\n  const algorithmsMap = {\n    dijkstra: 'Dijkstra',\n    astar: 'A* Search',\n    greedy: 'Greedy BFS',\n    dfs: 'DFS',\n    bfs: 'BFS',\n  };\n  const algorithmsPlaceholder = 'Algorithm';\n\n  const mazesMap = {\n    random: 'Random',\n    dfs: 'DFS',\n    recursiveDivision: 'Recursive Division',\n    kruskal: 'Kruskal',\n    prim: 'Prim',\n  };\n  const mazePlaceholder = 'Maze';\n\n  const speedMap = {\n    slow: 'Slow',\n    medium: 'Medium',\n    fast: 'Fast',\n  };\n  const speedPlaceholder = 'Speed';\n\n  return (\n    <div className='topBar'>\n      <h1 className='title'>Path Visualizer</h1>\n      <div className='optionsContainer'>\n        <div className='topBarItemContainer'>\n          <Select\n            option={algorithm}\n            onChange={onAlgorithmChange}\n            options={Object.keys(algorithmsMap)}\n            optionsMap={algorithmsMap}\n            placeholder={algorithmsPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={speed}\n            onChange={onSpeedChange}\n            options={Object.keys(speedMap)}\n            optionsMap={speedMap}\n            placeholder={speedPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={maze}\n            onChange={onMazeChange}\n            options={Object.keys(mazesMap)}\n            optionsMap={mazesMap}\n            placeholder={mazePlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <button\n            className={\n              isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton'\n            }\n            onClick={handleAlgorithmSubmit}\n          >\n            Visualize\n          </button>\n          <button\n            className={\n              (isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton') +\n              ' resetButton'\n            }\n            onClick={handleResetClick}\n          >\n            Reset\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TopBar;\n","import React from 'react';\nimport './../styles/Legend.css';\n\nconst Legend = ({ name, img }) => {\n  return (\n    <span className='legendContainer'>\n      <span className={`legend ${name}Legend`}>\n        {img && (\n          <img className='legendImg' src={img} alt={img} draggable='false' />\n        )}\n      </span>\n      <span className='legendText'>{name}</span>\n    </span>\n  );\n};\n\nexport default Legend;\n","import React, { useState, useRef } from 'react';\nimport './../styles/Tutorial.css';\nimport mapLogo from './../images/map.svg';\nimport algorithmLogo from './../images/algorithm.svg';\nimport creativityLogo from './../images/creativity.svg';\n\nconst Tutorial = (props) => {\n  const [textIndex, setTextIndex] = useState(0);\n  const [prevButtonStyle, setPrevButtonStyle] = useState({\n    backgroundColor: '#94caec',\n  });\n  const [nextButtonStyle, setNextButtonStyle] = useState({});\n  const [shouldShowAlgorithms, setShouldShowAlgorithms] = useState(false);\n  const [shouldShowSiteOptions, setShouldShowSiteOptions] = useState(false);\n  const [shouldShowMapLogo, setShouldShowMapLogo] = useState(true);\n  const [shouldShowAlgorithmLogo, setShouldShowAlgorithmLogo] = useState(false);\n  const [shouldShowCreativityLogo, setShouldShowCreativityLogo] = useState(\n    false\n  );\n  const tutorialTextContainerRef = useRef(null);\n\n  const texts = [\n    [\n      'Pathfinding, or the process of finding a route between two points, is an ' +\n        'important topic in computer science and graph theory.',\n      'Tasks, like solving mazes, navigating video game terrain, and calculating ' +\n        'Google Maps, all utilize pathfinding techniques.',\n    ],\n    [\n      'Over time, different algorithms have emerged in pathfinding. Some are ' +\n        'designed to guarantee the shortest path, while others trade optimality ' +\n        'for speed.',\n    ],\n    ['You can play around with and visualize how these algorithms work.'],\n  ];\n  const algorithmsIndex = 1;\n  const siteOptionsIndex = 2;\n  const mapLogoIndex = 0;\n  const algorithmLogoIndex = 1;\n  const creativityLogoIndex = 2;\n\n  const algorithms = [\n    ['Dijkstra:', 'Gurantees Shortest Path', 'Weighted', 'Slow'],\n    ['A* Search:', 'Guarantees Shortest Path', 'Weighted', 'Medium'],\n    ['Greedy BFS:', \"Doesn't Guarantee Shortest Path\", 'Weighted', 'Fast'],\n    ['BFS:', 'Guarantees Shortest Path', 'Unweighted', 'Slow'],\n    ['DFS:', \"Doesn't Guarantee Shortest Path\", 'Unweighted', 'Slow'],\n  ];\n\n  const siteOptions = [\n    ['Move around the start and end square'],\n    ['Click and drag to add walls (impenetrable)'],\n    ['Hold W to add weights (penetrable, cost 10 squares)'],\n    [\n      'Move around the start and end square after a visualization to see how the new position affects the path',\n    ],\n    [\n      'Adjust the speed of visualization as well as generate mazes to see how these algorithms solve them!',\n    ],\n  ];\n\n  const onSkip = () => {\n    props.setShouldShow(false);\n  };\n  const onPrev = () => {\n    if (textIndex > 0) {\n      setTutorialPage(textIndex - 1);\n      setTextIndex((i) => i - 1);\n    }\n  };\n  const onNext = () => {\n    if (textIndex < texts.length - 1) {\n      setTutorialPage(textIndex + 1);\n      setTextIndex((i) => i + 1);\n    }\n  };\n\n  const setTutorialPage = (textIndex) => {\n    tutorialTextContainerRef.current.scrollTop = 0;\n    if (textIndex === texts.length - 1) {\n      setNextButtonStyle({\n        backgroundColor: '#94caec',\n      });\n    } else {\n      setNextButtonStyle({});\n    }\n    if (textIndex === 0) {\n      setPrevButtonStyle({\n        backgroundColor: '#94caec',\n      });\n    } else {\n      setPrevButtonStyle({});\n    }\n    setShouldShowAlgorithms(textIndex === algorithmsIndex);\n    setShouldShowSiteOptions(textIndex === siteOptionsIndex);\n    setShouldShowMapLogo(textIndex === mapLogoIndex);\n    setShouldShowAlgorithmLogo(textIndex === algorithmLogoIndex);\n    setShouldShowCreativityLogo(textIndex === creativityLogoIndex);\n  };\n\n  return (\n    props.shouldShow && (\n      <div className='tutorialPageContainer'>\n        <div className='tutorialPage'>\n          <div className='tutorialTextContainer' ref={tutorialTextContainerRef}>\n            {shouldShowMapLogo && (\n              <img src={mapLogo} className='mapLogo' alt='map logo' />\n            )}\n            {shouldShowAlgorithmLogo && (\n              <img\n                src={algorithmLogo}\n                className='algorithmLogo'\n                alt='algorithm logo'\n              />\n            )}\n            {shouldShowCreativityLogo && (\n              <img\n                src={creativityLogo}\n                className='creativityLogo'\n                alt='creativity logo'\n              />\n            )}\n            {texts[textIndex].map((text) => (\n              <p key={text} className='tutorialText'>\n                {text}\n              </p>\n            ))}\n            {shouldShowAlgorithms && (\n              <div className='algorithmListContainer'>\n                <table className='algorithmList'>\n                  <tbody>\n                    {algorithms.map((alg) => (\n                      <tr key={alg}>\n                        {alg.map((elem) => (\n                          <td key={elem}>{elem}</td>\n                        ))}\n                      </tr>\n                    ))}\n                  </tbody>\n                </table>\n              </div>\n            )}\n            {shouldShowSiteOptions && (\n              <div className='siteOptionsListContainer'>\n                <ul className='siteOptionsList'>\n                  {siteOptions.map((option) => (\n                    <li key={option}>{option}</li>\n                  ))}\n                </ul>\n              </div>\n            )}\n          </div>\n          <div className='buttonsContainer'>\n            <div className='directionContainer'>\n              <button\n                className='prevButton'\n                onClick={onPrev}\n                style={prevButtonStyle}\n              >\n                {String.fromCharCode(8592)}\n              </button>\n              <button\n                className='nextButton'\n                onClick={onNext}\n                style={nextButtonStyle}\n              >\n                {String.fromCharCode(8594)}\n              </button>\n            </div>\n            <div className='skipContainer'>\n              <button className='skipButton' onClick={onSkip}>\n                {String.fromCharCode(10005)}\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    )\n  );\n};\n\nexport default Tutorial;\n","import React, { useState, useEffect, useCallback } from 'react';\nimport Grid from './Grid.js';\nimport TopBar from './TopBar.js';\nimport Legend from './Legend.js';\nimport Tutorial from './Tutorial.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/App.css';\n\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\n\nfunction App() {\n  const [grid, setGrid] = useState(GridConstants.INITIAL_GRID);\n  const [startIsCovering, setStartIsCovering] = useState(\n    GridConstants.DEFAULT_SQ\n  );\n  const [endIsCovering, setEndIsCovering] = useState(GridConstants.DEFAULT_SQ);\n  const [isTutorialShowing, setIsTutorialShowing] = useState(true);\n  const [algorithm, setAlgorithm] = useState(null);\n  const [speed, setSpeed] = useState('fast');\n  const [maze, setMaze] = useState(null);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isAnimatingFinished, setIsAnimatingFinished] = useState(false);\n\n  const resetGrid = useCallback(() => {\n    updateDimensions();\n    setGrid(GridConstants.INITIAL_GRID);\n    setIsAnimatingFinished(false);\n    setStartIsCovering(GridConstants.DEFAULT_SQ);\n    setEndIsCovering(GridConstants.DEFAULT_SQ);\n    setAlgorithm(null);\n    setMaze(null);\n    setSpeed('fast');\n  }, []);\n\n  // initialize window\n  useEffect(() => {\n    resetGrid();\n  }, [resetGrid]);\n\n  // update grid on resize\n  useEffect(() => {\n    if (!isAnimating) {\n      window.addEventListener('resize', resetGrid);\n      return () => window.removeEventListener('resize', resetGrid);\n    }\n  }, [isAnimating, resetGrid]);\n\n  const updateDimensions = () => {\n    const topBarHeight = document.getElementsByClassName('topBar')[0]\n      .offsetHeight;\n    const legendsHeight = document.getElementsByClassName('legendsContainer')[0]\n      .offsetHeight;\n    const gridVerticalMargin = 20;\n    const gridHorizontalMargin = 30;\n    let width = Math.floor((window.innerWidth - gridHorizontalMargin) / 25);\n    let height = Math.floor(\n      (window.innerHeight - topBarHeight - legendsHeight - gridVerticalMargin) /\n        25\n    );\n    // minimum width and height\n    if (width < 10) width = 10;\n    if (height < 5) height = 5;\n    GridConstants.update(width, height);\n  };\n\n  const legends = [\n    {\n      name: 'Start',\n      img: start,\n    },\n    {\n      name: 'End',\n      img: end,\n    },\n    {\n      name: 'Weight',\n      img: weight,\n    },\n    {\n      name: 'Wall',\n    },\n    {\n      name: 'Visited',\n    },\n    {\n      name: 'Path',\n    },\n  ];\n\n  const gridStyle = {\n    gridTemplateColumns: `repeat(${GridConstants.WIDTH}, 25px)`,\n    gridTemplateRows: `repeat(${GridConstants.HEIGHT}, 25px)`,\n  };\n\n  return (\n    <div className='page'>\n      <TopBar\n        grid={grid}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        setStartIsCovering={setStartIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        setIsAnimating={setIsAnimating}\n        setIsAnimatingFinished={setIsAnimatingFinished}\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        speed={speed}\n        setSpeed={setSpeed}\n        maze={maze}\n        setMaze={setMaze}\n        isTutorialShowing={isTutorialShowing}\n      />\n      <div className='legendsContainer'>\n        {legends.map((legend) => (\n          <Legend key={legend.name} name={legend.name} img={legend.img} />\n        ))}\n      </div>\n      <Tutorial\n        shouldShow={isTutorialShowing}\n        setShouldShow={setIsTutorialShowing}\n      />\n      <Grid\n        grid={grid}\n        gridStyle={gridStyle}\n        setGrid={setGrid}\n        startIsCovering={startIsCovering}\n        setStartIsCovering={setStartIsCovering}\n        endIsCovering={endIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        isAnimatingFinished={isAnimatingFinished}\n        algorithm={algorithm}\n        isTutorialShowing={isTutorialShowing}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App className='page' />, document.getElementById('root'));\n"],"sourceRoot":""}