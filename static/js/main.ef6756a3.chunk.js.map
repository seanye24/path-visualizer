{"version":3,"sources":["images/weight.svg","images/start.svg","images/end.svg","components/Square.js","services/Algorithms.js","services/Animations.js","components/Grid.js","components/Select.js","services/Maze.js","components/TopBar.js","components/Legend.js","components/App.js","index.js"],"names":["module","exports","React","memo","props","id","className","onMouseDown","onMouseUp","onMouseOver","onKeyDown","onKeyUp","tabIndex","Grid","WEIGHT_SQ","VISITED_WEIGHT_SQ","VISITED_FINISHED_WEIGHT_SQ","PATH_WEIGHT_SQ","PATH_FINISHED_WEIGHT_SQ","src","weight","draggable","alt","START_SQ","PATH_HEAD_SQ","start","END_SQ","end","grid","findIndex","sq","prev","visited","weights","Array","SIZE","fill","Number","MAX_SAFE_INTEGER","pq","currSquare","shift","push","moves","WIDTH","map","move","filter","nextSquare","validMove","moveWeight","WALL_SQ","includes","splice","indexOf","inserted","i","length","path","unshift","heuristic","Math","abs","floor","dist","count","stack","console","log","pop","queue","clearAnimate","setGrid","nextGrid","DEFAULT_SQ","animate","algorithm","speed","shouldDelay","a","Promise","resolve","isAnimating","isAnimatingFinished","pathDelay","visitedDelay","Algorithms","square","tick","prevSquare","changeSquare","ind","squareType","VISITED_SQ","VISITED_HEAD_SQ","VISITED_FINISHED_SQ","PATH_SQ","PATH_FINISHED_SQ","wait","ms","setTimeout","delay","getRow","getCol","getCoor","startIsCovering","setStartIsCovering","endIsCovering","setEndIsCovering","useState","isMouseDown","setIsMouseDown","isHoldingStart","setIsHoldingStart","isHoldingEnd","setIsHoldingEnd","isWDown","setIsWDown","mouseOver","setMouseOver","startSq","endSq","useEffect","Animations","e","key","renderSquare","HEIGHT","INITIAL_START","INITIAL_END","getSq","row","col","validMazeMove","endRow","endCol","Select","customSelectStyle","menu","provided","state","backgroundColor","width","border","margin","padding","menuList","borderRadius","container","height","display","alignItems","control","menuIsOpen","boxShadow","fontFamily","fontWeight","fontSize","cursor","userSelect","color","hasValue","dropdownIndicator","indicatorSeparator","placeholder","option","singleValue","whiteSpace","overflow","textOverflow","paddingRight","maxWidth","lineHeight","top","valueContainer","styles","options","value","label","optionsMap","onChange","data","isSearchable","tabSelectsValue","generateMaze","maze","resetGrid","finished","randomMaze","dfs","recursiveDivision","kruskal","prim","drawMazeBorder","topRow","bottomRow","leftCol","rightCol","generateWallGrid","getRandomElement","array","random","shuffleArray","newArray","getClosestEmptyTileFrom","from","reduce","closest","idx","closestDist","generateStartEndPosition","idealStart","idealEnd","Set","nextMove","nextMoves","has","add","divide","rowRange","colRange","possibleRows","possibleRowHoles","possibleCols","possibleColHoles","randomRow","drawRow","randomColHole","randomHole","randomCol","drawCol","treeSet","wallMap","iRow","iCol","Object","entries","wall","sq1","sq2","union","forEach","neighborSquares","neighborWalls","t","r","b","l","visitedSquares","visitedWalls","randomWall","TopBar","setIsAnimating","setIsAnimatingFinished","setAlgorithm","setMaze","setSpeed","setStartSq","setEndSq","handleAlgorithmSubmit","event","preventDefault","promise","handleMazeSubmit","Maze","algorithmsMap","dijkstra","astar","greedy","bfs","mazesMap","speedMap","slow","medium","fast","alg","keys","onClick","Legend","name","img","App","initialGrid","legends","legend","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ef6756a3.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.f8a5f7dd.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.ff2b9671.svg\";","module.exports = __webpack_public_path__ + \"static/media/end.93326d55.svg\";","import React from 'react';\n// import Grid from './Grid.js';\nimport './../styles/Square.css';\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\nimport Grid from './Grid';\n\nconst Square = (props) => {\n  return (\n    <div\n      id={props.id}\n      className={props.className}\n      onMouseDown={props.onMouseDown}\n      onMouseUp={props.onMouseUp}\n      onMouseOver={props.onMouseOver}\n      onKeyDown={props.onKeyDown}\n      onKeyUp={props.onKeyUp}\n      tabIndex={-1}>\n      {(props.className === Grid.WEIGHT_SQ ||\n        props.className === Grid.VISITED_WEIGHT_SQ ||\n        props.className === Grid.VISITED_FINISHED_WEIGHT_SQ ||\n        props.className === Grid.PATH_WEIGHT_SQ ||\n        props.className === Grid.PATH_FINISHED_WEIGHT_SQ) && (\n        <img\n          src={weight}\n          className='weightImg'\n          draggable='false'\n          alt='weight'\n        />\n      )}\n      {(props.className === Grid.START_SQ ||\n        props.className === Grid.PATH_HEAD_SQ) && (\n        <img src={start} className='startImg' draggable='false' alt='start' />\n      )}\n      {props.className === Grid.END_SQ && (\n        <img src={end} className='endImg' draggable='false' alt='end' />\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(Square);\n","import Grid from './../components/Grid';\n\nconst dijkstra = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(Grid.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === Grid.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (moveWeight < weights[pq[i]]) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst astar = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(Grid.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const heuristic = (start, end) => {\n    return (\n      Math.abs(Math.floor(start / Grid.WIDTH) - Math.floor(end / Grid.WIDTH)) +\n      Math.abs((start % Grid.WIDTH) - (end % Grid.WIDTH))\n    );\n  };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === Grid.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (\n              moveWeight + heuristic(nextSquare, end) <\n              weights[pq[i]] + heuristic(pq[i], end)\n            ) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  let path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n\n  return [visited, path];\n};\n\nconst greedy = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = { start: 1 };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // ignore mountains and decentivize weights\n      let moveWeight = Grid.dist(nextSquare, end);\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === Grid.WEIGHT_SQ) {\n        moveWeight += 10;\n      }\n\n      // insert into priority queue\n      if (!pq.includes(nextSquare) && !visited.includes(nextSquare)) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n        let inserted = false;\n        for (let i = 0; i < pq.length; i++) {\n          if (moveWeight < weights[pq[i]]) {\n            pq.splice(i, 0, nextSquare);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          pq.push(nextSquare);\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > Grid.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst dfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const stack = [start];\n  while (stack.length > 0) {\n    console.log('running dfs');\n    const currSquare = stack.pop();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // ignore mountains\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      }\n\n      // insert into stack\n      if (!visited.includes(nextSquare) && !stack.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        stack.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > Grid.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst bfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const queue = [start];\n  while (queue.length > 0) {\n    console.log('running bfs');\n    const currSquare = queue.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // ignore mountains\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      }\n\n      // insert into queue\n      if (!visited.includes(nextSquare) && !queue.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        queue.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > Grid.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nexport default { dijkstra, astar, greedy, dfs, bfs };\n","import Grid from './../components/Grid';\nimport Algorithms from './Algorithms';\n\nconst clearAnimate = (grid, setGrid) => {\n  const nextGrid = grid.map((sq) => {\n    if (sq === Grid.START_SQ || sq === Grid.END_SQ || sq === Grid.WALL_SQ) {\n      return sq;\n    } else if (\n      sq === Grid.WEIGHT_SQ ||\n      sq === Grid.VISITED_WEIGHT_SQ ||\n      sq === Grid.VISITED_FINISHED_WEIGHT_SQ ||\n      sq === Grid.PATH_WEIGHT_SQ ||\n      sq === Grid.PATH_FINISHED_WEIGHT_SQ\n    ) {\n      return Grid.WEIGHT_SQ;\n    } else {\n      return Grid.DEFAULT_SQ;\n    }\n  });\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst animate = async (algorithm, grid, setGrid, speed, shouldDelay) => {\n  if (!algorithm || !speed) {\n    return Promise.resolve({ isAnimating: false, isAnimatingFinished: false });\n  }\n\n  let pathDelay = 50;\n  let visitedDelay;\n  if (shouldDelay) {\n    switch (speed) {\n      case 'none':\n        break;\n      case 'slow':\n        visitedDelay = 50;\n        break;\n      case 'medium':\n        visitedDelay = 30;\n        break;\n      case 'fast':\n        visitedDelay = 15;\n        break;\n      default:\n    }\n  }\n\n  grid = clearAnimate(grid, setGrid);\n  let visited, path;\n  switch (algorithm) {\n    case 'dijkstra':\n      [visited, path] = Algorithms.dijkstra(grid);\n      break;\n    case 'astar':\n      [visited, path] = Algorithms.astar(grid);\n      break;\n    case 'greedy':\n      [visited, path] = Algorithms.greedy(grid);\n      break;\n    case 'dfs':\n      [visited, path] = Algorithms.dfs(grid);\n      break;\n    case 'bfs':\n      [visited, path] = Algorithms.bfs(grid);\n      break;\n    default:\n  }\n\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n  visited = visited.filter((square) => square !== start && square !== end);\n  path = path.filter((square) => square !== start && square !== end);\n\n  // animate visited\n  let tick = 0;\n  let prevSquare = null;\n  for (const square of visited) {\n    if (shouldDelay) {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += visitedDelay)\n        );\n      }\n      const squareType =\n        grid[square] === Grid.WEIGHT_SQ\n          ? Grid.VISITED_WEIGHT_SQ\n          : Grid.VISITED_SQ;\n      grid = changeSquare(grid, setGrid, square, Grid.VISITED_HEAD_SQ, tick);\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      const squareType =\n        grid[square] === Grid.WEIGHT_SQ\n          ? Grid.VISITED_FINISHED_WEIGHT_SQ\n          : Grid.VISITED_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n  if (shouldDelay && prevSquare) {\n    grid = changeSquare(\n      grid,\n      setGrid,\n      prevSquare.ind,\n      prevSquare.squareType,\n      tick\n    );\n  }\n\n  // animate path\n  prevSquare = null;\n  for (const square of path) {\n    if (shouldDelay) {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += pathDelay)\n        );\n      }\n      const squareType =\n        grid[square] === Grid.VISITED_WEIGHT_SQ\n          ? Grid.PATH_WEIGHT_SQ\n          : Grid.PATH_SQ;\n      grid = changeSquare(grid, setGrid, square, Grid.PATH_HEAD_SQ, tick);\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === Grid.VISITED_FINISHED_WEIGHT_SQ\n          ? Grid.PATH_FINISHED_WEIGHT_SQ\n          : Grid.PATH_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, Grid.PATH_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n    }\n  }\n  await wait(tick);\n  return Promise.resolve({ isAnimating: false, isAnimatingFinished: true });\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nexport default { animate };\n","import React, { useState, useEffect } from 'react';\nimport './../styles/Grid.css';\nimport Square from './Square.js';\nimport Animations from './../services/Animations.js';\n\nconst WIDTH = 67;\nconst HEIGHT = 45;\nconst SIZE = WIDTH * HEIGHT;\nconst INITIAL_START = 22 * WIDTH + 6;\nconst INITIAL_END = 22 * WIDTH + 60;\nconst DEFAULT_SQ = 'square';\nconst START_SQ = 'startSquare';\nconst END_SQ = 'endSquare';\nconst WALL_SQ = 'wallSquare';\nconst WEIGHT_SQ = 'weightSquare';\nconst VISITED_SQ = 'visitedSquare';\nconst VISITED_WEIGHT_SQ = 'visitedWeightSquare';\nconst VISITED_HEAD_SQ = 'visitedHeadSquare';\nconst VISITED_FINISHED_SQ = 'visitedFinishedSquare';\nconst VISITED_FINISHED_WEIGHT_SQ = 'visitedFinishedWeightSquare';\nconst PATH_SQ = 'pathSquare';\nconst PATH_WEIGHT_SQ = 'pathWeightSquare';\nconst PATH_HEAD_SQ = 'pathHeadSquare';\nconst PATH_FINISHED_SQ = 'pathFinishedSquare';\nconst PATH_FINISHED_WEIGHT_SQ = 'pathFinishedWeightSquare';\n\nconst getRow = (sq) => {\n  return Math.floor(sq / WIDTH);\n};\n\nconst getCol = (sq) => {\n  return sq % WIDTH;\n};\n\nconst getCoor = (sq) => {\n  return [getRow(sq), getCol(sq)];\n};\n\nconst getSq = (row, col) => {\n  return row * WIDTH + col;\n};\n\nconst dist = (start, end) =>\n  Math.abs(getRow(start) - getRow(end)) + Math.abs(getCol(start) - getCol(end));\n\nconst validMove = (start, end) => {\n  return end < SIZE && end >= 0 && Math.abs(getCol(end) - getCol(start)) <= 2;\n};\n\nconst validMazeMove = (start, end) => {\n  const [endRow, endCol] = getCoor(end);\n  return (\n    endRow >= 1 &&\n    endRow < HEIGHT - 1 &&\n    endCol >= 1 &&\n    endCol < WIDTH - 1 &&\n    validMove(start, end)\n  );\n};\n\nconst Grid = ({\n  grid,\n  setGrid,\n  startIsCovering,\n  setStartIsCovering,\n  endIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  isAnimatingFinished,\n  algorithm,\n}) => {\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isHoldingStart, setIsHoldingStart] = useState(false);\n  const [isHoldingEnd, setIsHoldingEnd] = useState(false);\n  const [isWDown, setIsWDown] = useState(false);\n  const [mouseOver, setMouseOver] = useState(-1);\n\n  const startSq = grid.findIndex((sq) => sq === START_SQ);\n  const endSq = grid.findIndex((sq) => sq === END_SQ);\n\n  useEffect(() => {\n    if (isMouseDown && !isAnimating) {\n      const nextGrid = [...grid];\n      if (\n        isHoldingStart &&\n        mouseOver !== startSq &&\n        grid[mouseOver] !== END_SQ\n      ) {\n        nextGrid[startSq] = startIsCovering;\n        setStartIsCovering(grid[mouseOver]);\n        nextGrid[mouseOver] = START_SQ;\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none', false);\n          return;\n        }\n      } else if (\n        isHoldingEnd &&\n        mouseOver !== endSq &&\n        grid[mouseOver] !== START_SQ\n      ) {\n        nextGrid[endSq] = endIsCovering;\n        setEndIsCovering(grid[mouseOver]);\n        nextGrid[mouseOver] = END_SQ;\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none', false);\n          return;\n        }\n      } else if (isWDown && mouseOver !== startSq && mouseOver !== endSq) {\n        nextGrid[mouseOver] =\n          grid[mouseOver] === WEIGHT_SQ ? DEFAULT_SQ : WEIGHT_SQ;\n      } else if (mouseOver !== startSq && mouseOver !== endSq) {\n        nextGrid[mouseOver] =\n          grid[mouseOver] === WALL_SQ ? DEFAULT_SQ : WALL_SQ;\n      }\n      setGrid(nextGrid);\n    }\n  }, [isMouseDown, mouseOver]);\n\n  const onMouseUp = (id) => {\n    if (!isAnimating) {\n      if (isHoldingStart) {\n        setIsHoldingStart(false);\n      } else if (isHoldingEnd) {\n        setIsHoldingEnd(false);\n      }\n      setIsMouseDown(false);\n    }\n  };\n\n  const onMouseDown = (id) => {\n    if (!isAnimating) {\n      if (id === startSq) {\n        setIsHoldingStart(true);\n      } else if (id === endSq) {\n        setIsHoldingEnd(true);\n      }\n      setIsMouseDown(true);\n    }\n  };\n\n  const onMouseOver = (id) => {\n    if (!isAnimating) {\n      setMouseOver(id);\n    }\n  };\n\n  const onKeyDown = (e) => {\n    if (!isAnimating) {\n      if (e.key === 'w') {\n        setIsWDown(true);\n      }\n    }\n  };\n\n  const onKeyUp = (e) => {\n    if (!isAnimating) {\n      if (e.key === 'w') {\n        setIsWDown(false);\n      }\n    }\n  };\n\n  const renderSquare = (sq, id) => {\n    return (\n      <Square\n        key={id}\n        id={id}\n        className={sq}\n        onMouseDown={() => onMouseDown(id)}\n        onMouseUp={() => onMouseUp(id)}\n        onMouseOver={() => onMouseOver(id)}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n      />\n    );\n  };\n\n  const renderGrid = () => {\n    return grid.map((sq, ind) => renderSquare(sq, ind));\n  };\n\n  return <div className='grid'>{renderGrid()}</div>;\n};\n\nexport default {\n  Grid,\n  WIDTH,\n  HEIGHT,\n  SIZE,\n  INITIAL_START,\n  INITIAL_END,\n  DEFAULT_SQ,\n  START_SQ,\n  END_SQ,\n  WALL_SQ,\n  WEIGHT_SQ,\n  VISITED_SQ,\n  VISITED_WEIGHT_SQ,\n  VISITED_HEAD_SQ,\n  VISITED_FINISHED_SQ,\n  VISITED_FINISHED_WEIGHT_SQ,\n  PATH_SQ,\n  PATH_WEIGHT_SQ,\n  PATH_HEAD_SQ,\n  PATH_FINISHED_SQ,\n  PATH_FINISHED_WEIGHT_SQ,\n  getRow,\n  getCol,\n  getCoor,\n  getSq,\n  dist,\n  validMove,\n  validMazeMove,\n};\n","import React from 'react';\nimport ReactSelect from 'react-select';\nimport './../styles/TopBar.css';\n\nconst Select = (props) => {\n  const customSelectStyle = {\n    menu: (provided, state) => ({\n      ...provided,\n      backgroundColor: 'rgb(17, 138, 178)',\n      width: '160px',\n      border: 'none',\n      margin: '0px',\n      padding: '0px',\n    }),\n    menuList: (provided, state) => ({\n      ...provided,\n      padding: '0px',\n      borderRadius: '0px 0px 5px 5px',\n    }),\n    container: (provided, state) => ({\n      ...provided,\n      height: '40px',\n      margin: 'auto 10px',\n      display: 'flex',\n      alignItems: 'center',\n    }),\n    control: (provided, state) => ({\n      ...provided,\n      width: '160px',\n      height: '100%',\n      border: 'none',\n      borderRadius: state.menuIsOpen ? '5px 5px 0px 0px' : '5px',\n      boxShadow: 'none',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n      fontSize: '20px',\n      cursor: 'pointer',\n      userSelect: 'none',\n\n      color: 'white',\n      backgroundColor:\n        state.hasValue || state.menuIsOpen\n          ? 'rgb(17, 138, 178)'\n          : 'transparent',\n      '&:hover': {\n        backgroundColor: 'rgb(17, 138, 178)',\n        color: 'white',\n        border: 'none',\n      },\n    }),\n    dropdownIndicator: (provided, state) => ({\n      margin: '3px',\n    }),\n    indicatorSeparator: (provided) => ({}),\n    placeholder: (provided, state) => ({}),\n    option: (provided, state) => ({\n      ...provided,\n      cursor: 'pointer',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n\n      color: 'white',\n      backgroundColor: 'rgb(17, 138, 178)',\n      '&:hover': {\n        color: 'rgb(38, 70, 83)',\n        backgroundColor: 'rgb(233, 196, 106)',\n      },\n    }),\n    singleValue: (provided) => ({\n      ...provided,\n      whiteSpace: 'nowrap',\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      paddingRight: '4px',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n      lineHeight: '36px',\n      top: '50%',\n      color: '',\n    }),\n    valueContainer: (provided) => ({\n      ...provided,\n      height: '100%',\n    }),\n  };\n\n  return (\n    <ReactSelect\n      styles={customSelectStyle}\n      options={props.options.map((option) => ({\n        value: option,\n        label: props.optionsMap[option],\n      }))}\n      value={\n        props.option && {\n          value: props.option,\n          label: props.optionsMap[props.option],\n        }\n      }\n      onChange={(data) => props.onChange(data.value)}\n      // onInputChange={(data) => props.onChange(data)}\n      placeholder={props.placeholder}\n      isSearchable={false}\n      tabSelectsValue={false}\n    />\n  );\n};\n\nexport default Select;\n","import Grid from '../components/Grid';\n\nconst generateMaze = async (maze, grid, setGrid, resetGrid, speed) => {\n  if (!maze) {\n    return Promise.resolve({ finished: false, grid: grid });\n  }\n  grid = new Array(Grid.SIZE).fill(Grid.DEFAULT_SQ);\n  setGrid(grid);\n\n  let delay = 10;\n  switch (maze) {\n    case 'random':\n      return await randomMaze(grid, setGrid, 0, delay);\n    case 'dfs':\n      return await dfs(grid, setGrid, 0, delay);\n    case 'recursiveDivision':\n      return await recursiveDivision(grid, setGrid, 0, delay);\n    case 'kruskal':\n      return await kruskal(grid, setGrid, 0, delay);\n    case 'prim':\n      return await prim(grid, setGrid, 0, delay);\n    default:\n  }\n};\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst drawRow = (grid, setGrid, tick, delay, row, colRange) => {\n  for (let i = colRange[0]; i <= colRange[1]; i++, tick += delay) {\n    const sq = row * Grid.WIDTH + i;\n    grid = changeSquare(grid, setGrid, sq, Grid.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawCol = (grid, setGrid, tick, delay, col, rowRange) => {\n  for (let i = rowRange[0]; i <= rowRange[1]; i++, tick += delay) {\n    const sq = i * Grid.WIDTH + col;\n    grid = changeSquare(grid, setGrid, sq, Grid.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawMazeBorder = (grid, setGrid, tick, delay) => {\n  console.log(tick);\n  for (let i = 0; i < Grid.WIDTH; i++, tick += delay) {\n    const topRow = Grid.getSq(0, i);\n    const bottomRow = Grid.getSq(Grid.HEIGHT - 1, i);\n    grid = changeSquare(grid, setGrid, topRow, Grid.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, bottomRow, Grid.WALL_SQ, tick);\n  }\n  for (let i = 0; i < Grid.HEIGHT; i++, tick += delay) {\n    const leftCol = Grid.getSq(i, 0);\n    const rightCol = Grid.getSq(i, Grid.WIDTH - 1);\n    grid = changeSquare(grid, setGrid, leftCol, Grid.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, rightCol, Grid.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst generateWallGrid = (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let row = 1; row < Grid.HEIGHT - 1; row++) {\n    for (let col = 1; col < Grid.WIDTH - 1; col++) {\n      if (!(row % 2 && col % 2)) {\n        grid[Grid.getSq(row, col)] = Grid.WALL_SQ;\n      }\n    }\n  }\n  setTimeout(() => {\n    setGrid(grid);\n  }, tick);\n  return [tick, [...grid]];\n};\n\nconst getRandomNumberBetween = (start, end) => {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n};\n\nconst getRandomElement = (array) => {\n  return array.splice(getRandomNumberBetween(0, array.length - 1), 1)[0];\n};\n\nconst shuffleArray = (array) => {\n  const newArray = [];\n  while (array.length > 0) {\n    newArray.push(getRandomElement(array));\n  }\n  return newArray;\n};\n\nconst getClosestEmptyTileFrom = (grid, from) => {\n  return grid.reduce((closest, sq, idx) => {\n    if (sq === Grid.DEFAULT_SQ) {\n      if (closest === -1) {\n        return idx;\n      } else {\n        const closestDist = Grid.dist(from, closest);\n        const sqDist = Grid.dist(from, idx);\n        return sqDist < closestDist ? idx : closest;\n      }\n    } else {\n      return closest;\n    }\n  }, -1);\n};\n\nconst generateStartEndPosition = (\n  grid,\n  setGrid,\n  idealStart,\n  idealEnd,\n  delay\n) => {\n  const start = getClosestEmptyTileFrom(grid, idealStart);\n  const end = getClosestEmptyTileFrom(grid, idealEnd);\n  grid = changeSquare(grid, setGrid, start, Grid.START_SQ, delay);\n  return changeSquare(grid, setGrid, end, Grid.END_SQ, delay);\n};\n\nconst randomMaze = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  console.log(tick);\n  for (let i = 0; i < grid.length; i++) {\n    if (Grid.validMazeMove(i, i) && Math.random() < 0.35) {\n      grid[i] = Grid.WALL_SQ;\n    }\n  }\n  setTimeout(() => setGrid(grid), tick);\n\n  grid = [...grid];\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(0, 0),\n    Grid.getSq(Grid.SIZE - 1, Grid.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst dfs = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  const start = Grid.getSq(1, 1);\n  const visited = new Set([start]);\n  const path = [start];\n  while (path.length > 0) {\n    const currSquare = path.pop();\n    let moves = [-2, 2, -2 * Grid.WIDTH, 2 * Grid.WIDTH];\n    moves = moves.filter((move) =>\n      Grid.validMazeMove(currSquare, currSquare + move)\n    );\n\n    while (moves.length > 0) {\n      const nextMove =\n        currSquare + moves.splice(Math.random() * moves.length, 1)[0];\n      const nextMoves = [(currSquare + nextMove) / 2, nextMove];\n      if (!visited.has(nextMove)) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[0],\n          Grid.DEFAULT_SQ,\n          (tick += delay)\n        );\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[1],\n          Grid.DEFAULT_SQ,\n          (tick += delay)\n        );\n        visited.add(nextMove);\n        path.push(nextMove);\n        path.push(nextMove);\n        break;\n      }\n    }\n  }\n\n  // place end as far away as possible from start\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.SIZE - 1, Grid.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst recursiveDivision = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n\n  [tick, grid] = divide(\n    grid,\n    setGrid,\n    tick,\n    delay,\n    [0, Grid.HEIGHT - 1],\n    [0, Grid.WIDTH - 1]\n  );\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.HEIGHT - 1, Grid.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst divide = (grid, setGrid, tick, delay, rowRange, colRange) => {\n  const [possibleRows, possibleRowHoles] = [[], []];\n  const [possibleCols, possibleColHoles] = [[], []];\n  for (let i = rowRange[0] + 1; i < rowRange[1]; i++) {\n    if ((i - rowRange[0]) % 2 === 0) {\n      possibleRows.push(i);\n    } else {\n      possibleRowHoles.push(i);\n    }\n  }\n  for (let i = colRange[0] + 1; i < colRange[1]; i++) {\n    if ((i - colRange[0]) % 2 === 0) {\n      possibleCols.push(i);\n    } else {\n      possibleColHoles.push(i);\n    }\n  }\n\n  if (possibleRows.length === 0 || possibleCols.length === 0) {\n    return [tick, grid];\n  } else {\n    if (possibleRows.length >= possibleCols.length) {\n      const randomRow = getRandomElement(possibleRows);\n      [tick, grid] = drawRow(grid, setGrid, tick, delay, randomRow, colRange);\n      const randomColHole = getRandomElement(possibleColHoles);\n      const randomHole = randomRow * Grid.WIDTH + randomColHole;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        Grid.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [rowRange[0], randomRow],\n        colRange\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [randomRow, rowRange[1]],\n        colRange\n      );\n    } else {\n      let randomCol = getRandomElement(possibleCols);\n      [tick, grid] = drawCol(grid, setGrid, tick, delay, randomCol, rowRange);\n      const randomRowHole = getRandomElement(possibleRowHoles);\n      const randomHole = randomRowHole * Grid.WIDTH + randomCol;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        Grid.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        colRange[0],\n        randomCol,\n      ]);\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        randomCol,\n        colRange[1],\n      ]);\n    }\n    return [tick, grid];\n  }\n};\n\nconst kruskal = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let treeSet = {};\n  let wallMap = {};\n\n  // fill wallMap and treeSet\n  for (let i = 0; i < Grid.SIZE; i++) {\n    const [iRow, iCol] = Grid.getCoor(i);\n    if (Grid.validMazeMove(i, i)) {\n      if (iRow % 2 && iCol % 2) {\n        treeSet[i] = new Set([i]);\n      } else {\n        if (iCol % 2) {\n          wallMap[i] = [i - Grid.WIDTH, i + Grid.WIDTH];\n        } else if (iRow % 2) {\n          wallMap[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  for (const [wall, [sq1, sq2]] of shuffleArray(Object.entries(wallMap))) {\n    if (!treeSet[sq1].has(sq2)) {\n      grid = changeSquare(\n        grid,\n        setGrid,\n        wall,\n        Grid.DEFAULT_SQ,\n        (tick += delay)\n      );\n      const union = new Set([...treeSet[sq1], ...treeSet[sq2]]);\n      treeSet[sq1].forEach((sq) => (treeSet[sq] = union));\n      treeSet[sq2].forEach((sq) => (treeSet[sq] = union));\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.HEIGHT - 1, Grid.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst prim = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let neighborSquares = {};\n  let neighborWalls = {};\n\n  // fill walls\n  for (let i = 0; i < Grid.SIZE; i++) {\n    if (Grid.validMazeMove(i, i)) {\n      const [iRow, iCol] = Grid.getCoor(i);\n      if (iRow % 2 && iCol % 2) {\n        const t = Grid.validMazeMove(i, i - Grid.WIDTH) ? [i - Grid.WIDTH] : [];\n        const r = Grid.validMazeMove(i, i + 1) ? [i + 1] : [];\n        const b = Grid.validMazeMove(i, i + Grid.WIDTH) ? [i + Grid.WIDTH] : [];\n        const l = Grid.validMazeMove(i, i - 1) ? [i - 1] : [];\n        neighborWalls[i] = [...t, ...r, ...b, ...l];\n      } else if (iRow % 2 ^ iCol % 2) {\n        if (iCol % 2) {\n          neighborSquares[i] = [i - Grid.WIDTH, i + Grid.WIDTH];\n        } else if (iRow % 2) {\n          neighborSquares[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  const visitedSquares = new Set([Grid.getSq(1, 1)]);\n  let visitedWalls = [...neighborWalls[Grid.getSq(1, 1)]];\n  while (visitedWalls.length > 0) {\n    const randomWall = getRandomElement(visitedWalls);\n    const [sq1, sq2] = neighborSquares[randomWall];\n    if (sq1 > Grid.SIZE || sq2 > Grid.SIZE) {\n    }\n    if (visitedSquares.has(sq1) ^ visitedSquares.has(sq2)) {\n      if (!visitedSquares.has(sq1)) {\n        visitedSquares.add(sq1);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq1]];\n      } else {\n        visitedSquares.add(sq2);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq2]];\n      }\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomWall,\n        Grid.DEFAULT_SQ,\n        (tick += delay)\n      );\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.HEIGHT - 1, Grid.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nexport default { generateMaze };\n","import React, { useEffect } from 'react';\nimport Select from './Select';\nimport './../styles/TopBar.css';\nimport Animations from './../services/Animations.js';\nimport Maze from './../services/Maze.js';\nimport Grid from './Grid';\n\nconst TopBar = (props) => {\n  const {\n    grid,\n    setGrid,\n    resetGrid,\n    setIsAnimating,\n    setIsAnimatingFinished,\n    algorithm,\n    setAlgorithm,\n    maze,\n    setMaze,\n    speed,\n    setSpeed,\n    isAnimating,\n    setStartSq,\n    setEndSq,\n  } = props;\n\n  const handleAlgorithmSubmit = async (event) => {\n    event.preventDefault();\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Animations.animate(\n        algorithm,\n        grid,\n        setGrid,\n        speed,\n        true\n      );\n      setIsAnimating(promise.isAnimating);\n      setIsAnimatingFinished(promise.isAnimatingFinished);\n    }\n  };\n\n  const handleMazeSubmit = async (maze) => {\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Maze.generateMaze(maze, grid, setGrid, resetGrid);\n      setIsAnimating(promise.finished);\n      const start = promise.grid.findIndex((sq) => sq === Grid.START_SQ);\n      const end = promise.grid.findIndex((sq) => sq === Grid.END_SQ);\n      setStartSq(start);\n      setEndSq(end);\n      setIsAnimatingFinished(false);\n    }\n  };\n\n  const onAlgorithmChange = (alg) => {\n    setAlgorithm(alg);\n  };\n\n  const onMazeChange = (maze) => {\n    setMaze(maze);\n    handleMazeSubmit(maze);\n  };\n\n  const onSpeedChange = (speed) => {\n    setSpeed(speed);\n  };\n\n  const handleResetClick = (e) => {\n    if (!isAnimating) {\n      e.preventDefault();\n      resetGrid();\n    }\n  };\n\n  const algorithmsMap = {\n    dijkstra: 'Dijkstra',\n    astar: 'A* Search',\n    greedy: 'Greedy BFS',\n    dfs: 'DFS',\n    bfs: 'BFS',\n  };\n  const algorithmsPlaceholder = 'Algorithm';\n\n  const mazesMap = {\n    random: 'Random',\n    dfs: 'DFS',\n    recursiveDivision: 'Recursive Division',\n    kruskal: 'Kruskal',\n    prim: 'Prim',\n  };\n  const mazePlaceholder = 'Maze';\n\n  const speedMap = {\n    slow: 'Slow',\n    medium: 'Medium',\n    fast: 'Fast',\n  };\n  const speedPlaceholder = 'Speed';\n\n  return (\n    <div className='topBar'>\n      <h1 className='title'>Path Visualizer</h1>\n      <div className='optionsContainer'>\n        <div className='topBarItemContainer'>\n          <Select\n            option={algorithm}\n            onChange={onAlgorithmChange}\n            options={Object.keys(algorithmsMap)}\n            optionsMap={algorithmsMap}\n            placeholder={algorithmsPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={speed}\n            onChange={onSpeedChange}\n            options={Object.keys(speedMap)}\n            optionsMap={speedMap}\n            placeholder={speedPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={maze}\n            onChange={onMazeChange}\n            options={Object.keys(mazesMap)}\n            optionsMap={mazesMap}\n            placeholder={mazePlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <button\n            className={\n              isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton'\n            }\n            onClick={handleAlgorithmSubmit}>\n            Visualize\n          </button>\n          <button\n            className={\n              (isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton') +\n              ' resetButton'\n            }\n            onClick={handleResetClick}>\n            Reset\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TopBar;\n","import React from 'react';\nimport './../styles/Legend.css';\n\nconst Legend = ({ name, img }) => {\n  return (\n    <span className='legendContainer'>\n      <span className={`legend ${name}Legend`}>\n        {img && (\n          <img className='legendImg' src={img} alt={img} draggable='false' />\n        )}\n      </span>\n      <span className='legendText'>{name}</span>\n    </span>\n  );\n};\n\nexport default Legend;\n","import React, { useState } from 'react';\nimport './../styles/App.css';\nimport Grid from './Grid.js';\nimport TopBar from './TopBar.js';\nimport Legend from './Legend.js';\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\n\nfunction App() {\n  const initialGrid = new Array(Grid.SIZE).fill(Grid.DEFAULT_SQ);\n  initialGrid[Grid.INITIAL_START] = Grid.START_SQ;\n  initialGrid[Grid.INITIAL_END] = Grid.END_SQ;\n\n  const [grid, setGrid] = useState(initialGrid);\n  const [startIsCovering, setStartIsCovering] = useState(Grid.DEFAULT_SQ);\n  const [endIsCovering, setEndIsCovering] = useState(Grid.DEFAULT_SQ);\n  const [algorithm, setAlgorithm] = useState(null);\n  const [maze, setMaze] = useState(null);\n  const [speed, setSpeed] = useState('medium');\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isAnimatingFinished, setIsAnimatingFinished] = useState(false);\n  const [startSq, setStartSq] = useState(Grid.INITIAL_START);\n  const [endSq, setEndSq] = useState(Grid.INITIAL_END);\n\n  const legends = [\n    {\n      name: 'Start',\n      img: start,\n    },\n    {\n      name: 'End',\n      img: end,\n    },\n    {\n      name: 'Weight',\n      img: weight,\n    },\n    {\n      name: 'Wall',\n    },\n    {\n      name: 'Visited',\n    },\n    {\n      name: 'Path',\n    },\n  ];\n\n  const resetGrid = () => {\n    console.log('resetting grid');\n    setGrid(initialGrid);\n    setIsAnimatingFinished(false);\n    setStartIsCovering(Grid.DEFAULT_SQ);\n    setEndIsCovering(Grid.DEFAULT_SQ);\n    setStartSq(Grid.INITIAL_START);\n    setEndSq(Grid.INITIAL_END);\n    setAlgorithm(null);\n    setMaze(null);\n    setSpeed('medium');\n  };\n\n  return (\n    <div className='page'>\n      <TopBar\n        grid={grid}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        setIsAnimating={setIsAnimating}\n        setIsAnimatingFinished={setIsAnimatingFinished}\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        maze={maze}\n        setMaze={setMaze}\n        speed={speed}\n        setSpeed={setSpeed}\n        isAnimating={isAnimating}\n        setStartSq={setStartSq}\n        setEndSq={setEndSq}\n      />\n      <div className='legendsContainer'>\n        {legends.map((legend) => (\n          <Legend name={legend.name} img={legend.img} />\n        ))}\n      </div>\n      <Grid.Grid\n        grid={grid}\n        setGrid={setGrid}\n        startIsCovering={startIsCovering}\n        setStartIsCovering={setStartIsCovering}\n        endIsCovering={endIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        resetGrid={resetGrid}\n        isAnimating={isAnimating}\n        isAnimatingFinished={isAnimatingFinished}\n        algorithm={algorithm}\n        startSq={startSq}\n        endSq={endSq}\n        setStartSq={setStartSq}\n        setEndSq={setEndSq}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App className='page' />, document.getElementById('root'));\n"],"sourceRoot":""}