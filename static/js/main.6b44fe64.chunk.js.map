{"version":3,"sources":["images/weight.svg","images/start.svg","images/end.svg","services/GridConstants.js","components/Square.js","services/Algorithms.js","services/Animations.js","components/Grid.js","components/Select.js","services/Maze.js","components/TopBar.js","components/Legend.js","components/App.js","index.js"],"names":["module","exports","WIDTH","HEIGHT","SIZE","INITIAL_START","INITIAL_END","INITIAL_GRID","getRow","getCol","getCoor","getSq","dist","validMove","validMazeMove","GridConstants","DEFAULT_SQ","START_SQ","END_SQ","WALL_SQ","WEIGHT_SQ","VISITED_SQ","VISITED_WEIGHT_SQ","VISITED_HEAD_SQ","VISITED_FINISHED_SQ","VISITED_FINISHED_WEIGHT_SQ","PATH_SQ","PATH_WEIGHT_SQ","PATH_HEAD_SQ","PATH_FINISHED_SQ","PATH_FINISHED_WEIGHT_SQ","update","width","height","Math","floor","Array","fill","sq","row","col","start","end","abs","endRow","endCol","window","innerWidth","innerHeight","React","memo","props","id","className","onMouseEnter","onMouseDown","onMouseUp","onKeyDown","onKeyUp","tabIndex","src","weight","draggable","alt","grid","findIndex","prev","visited","weights","Number","MAX_SAFE_INTEGER","pq","currSquare","shift","push","moves","map","move","filter","nextSquare","moveWeight","includes","splice","indexOf","inserted","i","length","path","unshift","heuristic","count","stack","console","log","pop","queue","clearAnimate","setGrid","nextGrid","animate","algorithm","speed","a","Promise","resolve","isAnimating","isAnimatingFinished","pathDelay","visitedDelay","Algorithms","square","tick","prevSquare","changeSquare","ind","squareType","wait","ms","setTimeout","delay","Grid","gridStyle","startIsCovering","setStartIsCovering","endIsCovering","setEndIsCovering","useState","isMouseDown","setIsMouseDown","isHoldingStart","setIsHoldingStart","isHoldingEnd","setIsHoldingEnd","isWDown","setIsWDown","startSq","s","endSq","Animations","updateGridOnMouseEnter","updateGridOnMouseDown","e","key","renderSquare","sqType","style","Select","customSelectStyle","menu","provided","state","backgroundColor","border","margin","padding","menuList","borderRadius","container","display","alignItems","control","menuIsOpen","boxShadow","fontFamily","fontWeight","fontSize","cursor","userSelect","color","hasValue","dropdownIndicator","indicatorSeparator","placeholder","option","singleValue","whiteSpace","overflow","textOverflow","paddingRight","maxWidth","lineHeight","top","valueContainer","styles","options","value","label","optionsMap","onChange","data","isSearchable","tabSelectsValue","generateMaze","maze","resetGrid","finished","randomMaze","dfs","recursiveDivision","kruskal","prim","drawMazeBorder","topRow","bottomRow","leftCol","rightCol","generateWallGrid","getRandomElement","array","random","shuffleArray","newArray","getClosestEmptyTileFrom","from","reduce","closest","idx","closestDist","generateStartEndPosition","idealStart","idealEnd","Set","nextMove","nextMoves","has","add","divide","rowRange","colRange","possibleRows","possibleRowHoles","possibleCols","possibleColHoles","randomRow","drawRow","randomColHole","randomHole","randomCol","drawCol","treeSet","wallMap","iRow","iCol","Object","entries","wall","sq1","sq2","union","forEach","neighborSquares","neighborWalls","t","r","b","l","visitedSquares","visitedWalls","randomWall","TopBar","setIsAnimating","setIsAnimatingFinished","setAlgorithm","setMaze","setSpeed","handleAlgorithmSubmit","event","preventDefault","promise","handleMazeSubmit","Maze","algorithmsMap","dijkstra","astar","greedy","bfs","mazesMap","speedMap","slow","medium","fast","alg","keys","onClick","Legend","name","img","App","useEffect","updateDimensions","addEventListener","removeEventListener","legends","gridTemplateColumns","gridTemplateRows","legend","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6b44fe64.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.f8a5f7dd.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.ff2b9671.svg\";","module.exports = __webpack_public_path__ + \"static/media/end.93326d55.svg\";","let GridConstants = {};\nlet WIDTH,\n  HEIGHT,\n  SIZE,\n  INITIAL_START,\n  INITIAL_END,\n  INITIAL_GRID,\n  getRow,\n  getCol,\n  getCoor,\n  getSq,\n  dist,\n  validMove,\n  validMazeMove;\n\nGridConstants.DEFAULT_SQ = 'square';\nGridConstants.START_SQ = 'startSquare';\nGridConstants.END_SQ = 'endSquare';\nGridConstants.WALL_SQ = 'wallSquare';\nGridConstants.WEIGHT_SQ = 'weightSquare';\nGridConstants.VISITED_SQ = 'visitedSquare';\nGridConstants.VISITED_WEIGHT_SQ = 'visitedWeightSquare';\nGridConstants.VISITED_HEAD_SQ = 'visitedHeadSquare';\nGridConstants.VISITED_FINISHED_SQ = 'visitedFinishedSquare';\nGridConstants.VISITED_FINISHED_WEIGHT_SQ = 'visitedFinishedWeightSquare';\nGridConstants.PATH_SQ = 'pathSquare';\nGridConstants.PATH_WEIGHT_SQ = 'pathWeightSquare';\nGridConstants.PATH_HEAD_SQ = 'pathHeadSquare';\nGridConstants.PATH_FINISHED_SQ = 'pathFinishedSquare';\nGridConstants.PATH_FINISHED_WEIGHT_SQ = 'pathFinishedWeightSquare';\n\nconst update = (width, height) => {\n  WIDTH = width;\n  HEIGHT = height;\n\n  // maintain odd number of rows and cols for maze\n  if (WIDTH % 2 === 0) {\n    WIDTH--;\n  }\n  if (HEIGHT % 2 === 0) {\n    HEIGHT--;\n  }\n  SIZE = WIDTH * HEIGHT;\n  INITIAL_START = (Math.floor(HEIGHT / 2) - 1) * WIDTH + Math.floor(WIDTH / 6);\n  INITIAL_END =\n    (Math.floor(HEIGHT / 2) - 1) * WIDTH + Math.floor((WIDTH * 5) / 6);\n  INITIAL_GRID = new Array(SIZE).fill(GridConstants.DEFAULT_SQ);\n  INITIAL_GRID[INITIAL_START] = GridConstants.START_SQ;\n  INITIAL_GRID[INITIAL_END] = GridConstants.END_SQ;\n\n  getRow = (sq) => Math.floor(sq / WIDTH);\n\n  getCol = (sq) => sq % WIDTH;\n\n  getCoor = (sq) => [getRow(sq), getCol(sq)];\n\n  getSq = (row, col) => row * WIDTH + col;\n\n  dist = (start, end) =>\n    Math.abs(getRow(start) - getRow(end)) +\n    Math.abs(getCol(start) - getCol(end));\n\n  validMove = (start, end) =>\n    end < SIZE && end >= 0 && Math.abs(getCol(end) - getCol(start)) <= 2;\n\n  validMazeMove = (start, end) => {\n    const [endRow, endCol] = getCoor(end);\n    return (\n      endRow >= 1 &&\n      endRow < HEIGHT - 1 &&\n      endCol >= 1 &&\n      endCol < WIDTH - 1 &&\n      validMove(start, end)\n    );\n  };\n\n  GridConstants.WIDTH = WIDTH;\n  GridConstants.HEIGHT = HEIGHT;\n  GridConstants.SIZE = SIZE;\n  GridConstants.INITIAL_START = INITIAL_START;\n  GridConstants.INITIAL_END = INITIAL_END;\n  GridConstants.INITIAL_GRID = INITIAL_GRID;\n  GridConstants.getRow = getRow;\n  GridConstants.getCol = getCol;\n  GridConstants.getCoor = getCoor;\n  GridConstants.getSq = getSq;\n  GridConstants.dist = dist;\n  GridConstants.validMove = validMove;\n  GridConstants.validMazeMove = validMazeMove;\n  GridConstants.update = update;\n};\n\nupdate(\n  Math.floor((window.innerWidth - 25) / 25),\n  Math.floor((window.innerHeight - 150) / 25)\n);\n\nexport default GridConstants;\n","import React from 'react';\nimport './../styles/Square.css';\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\nimport GridConstants from './../services/GridConstants.js'\n\nconst Square = (props) => {\n  return (\n    <div\n      id={props.id}\n      className={props.className}\n      onMouseEnter={props.onMouseEnter}\n      onMouseDown={props.onMouseDown}\n      onMouseUp={props.onMouseUp}\n      onKeyDown={props.onKeyDown}\n      onKeyUp={props.onKeyUp}\n      tabIndex={-1}>\n      {(props.className === GridConstants.WEIGHT_SQ ||\n        props.className === GridConstants.VISITED_WEIGHT_SQ ||\n        props.className === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n        props.className === GridConstants.PATH_WEIGHT_SQ ||\n        props.className === GridConstants.PATH_FINISHED_WEIGHT_SQ) && (\n        <img\n          src={weight}\n          className='weightImg'\n          draggable='false'\n          alt='weight'\n        />\n      )}\n      {(props.className === GridConstants.START_SQ ||\n        props.className === GridConstants.PATH_HEAD_SQ) && (\n        <img src={start} className='startImg' draggable='false' alt='start' />\n      )}\n      {props.className === GridConstants.END_SQ && (\n        <img src={end} className='endImg' draggable='false' alt='end' />\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(Square);\n","import GridConstants from './../services/GridConstants.js';\n\nconst dijkstra = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => GridConstants.validMove(currSquare, nextSquare))) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (moveWeight < weights[pq[i]]) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst astar = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const heuristic = (start, end) => {\n    return (\n      Math.abs(Math.floor(start / GridConstants.WIDTH) - Math.floor(end / GridConstants.WIDTH)) +\n      Math.abs((start % GridConstants.WIDTH) - (end % GridConstants.WIDTH))\n    );\n  };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => GridConstants.validMove(currSquare, nextSquare))) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (\n              moveWeight + heuristic(nextSquare, end) <\n              weights[pq[i]] + heuristic(pq[i], end)\n            ) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  let path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n\n  return [visited, path];\n};\n\nconst greedy = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = { start: 1 };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => GridConstants.validMove(currSquare, nextSquare))) {\n      // ignore mountains and decentivize weights\n      let moveWeight = GridConstants.dist(nextSquare, end);\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      }\n\n      // insert into priority queue\n      if (!pq.includes(nextSquare) && !visited.includes(nextSquare)) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n        let inserted = false;\n        for (let i = 0; i < pq.length; i++) {\n          if (moveWeight < weights[pq[i]]) {\n            pq.splice(i, 0, nextSquare);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          pq.push(nextSquare);\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst dfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const stack = [start];\n  while (stack.length > 0) {\n    console.log('running dfs');\n    const currSquare = stack.pop();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => GridConstants.validMove(currSquare, nextSquare))) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into stack\n      if (!visited.includes(nextSquare) && !stack.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        stack.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst bfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const queue = [start];\n  while (queue.length > 0) {\n    console.log('running bfs');\n    const currSquare = queue.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => GridConstants.validMove(currSquare, nextSquare))) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into queue\n      if (!visited.includes(nextSquare) && !queue.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        queue.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nexport default { dijkstra, astar, greedy, dfs, bfs };\n","import GridConstants from './../services/GridConstants.js';\nimport Algorithms from './Algorithms';\n\nconst clearAnimate = (grid, setGrid) => {\n  const nextGrid = grid.map((sq) => {\n    if (sq === GridConstants.START_SQ || sq === GridConstants.END_SQ || sq === GridConstants.WALL_SQ) {\n      return sq;\n    } else if (\n      sq === GridConstants.WEIGHT_SQ ||\n      sq === GridConstants.VISITED_WEIGHT_SQ ||\n      sq === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n      sq === GridConstants.PATH_WEIGHT_SQ ||\n      sq === GridConstants.PATH_FINISHED_WEIGHT_SQ\n    ) {\n      return GridConstants.WEIGHT_SQ;\n    } else {\n      return GridConstants.DEFAULT_SQ;\n    }\n  });\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst animate = async (algorithm, grid, setGrid, speed) => {\n  if (!algorithm || !speed) {\n    return Promise.resolve({ isAnimating: false, isAnimatingFinished: false });\n  }\n\n  let pathDelay = 50;\n  let visitedDelay;\n  switch (speed) {\n    case 'none':\n      break;\n    case 'slow':\n      visitedDelay = 70;\n      break;\n    case 'medium':\n      visitedDelay = 40;\n      break;\n    case 'fast':\n      visitedDelay = 25;\n      break;\n    default:\n  }\n\n  grid = clearAnimate(grid, setGrid);\n  let visited, path;\n  switch (algorithm) {\n    case 'dijkstra':\n      [visited, path] = Algorithms.dijkstra(grid);\n      break;\n    case 'astar':\n      [visited, path] = Algorithms.astar(grid);\n      break;\n    case 'greedy':\n      [visited, path] = Algorithms.greedy(grid);\n      break;\n    case 'dfs':\n      [visited, path] = Algorithms.dfs(grid);\n      break;\n    case 'bfs':\n      [visited, path] = Algorithms.bfs(grid);\n      break;\n    default:\n  }\n\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n  visited = visited.filter((square) => square !== start && square !== end);\n  path = path.filter((square) => square !== start && square !== end);\n\n  // animate visited\n  let tick = 0;\n  let prevSquare = null;\n  for (const square of visited) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += visitedDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_WEIGHT_SQ\n          : GridConstants.VISITED_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.VISITED_HEAD_SQ, tick);\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          : GridConstants.VISITED_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n  if (speed !== 'none' && prevSquare) {\n    grid = changeSquare(\n      grid,\n      setGrid,\n      prevSquare.ind,\n      prevSquare.squareType,\n      tick\n    );\n  }\n\n  // animate path\n  prevSquare = null;\n  for (const square of path) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += pathDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_WEIGHT_SQ\n          ? GridConstants.PATH_WEIGHT_SQ\n          : GridConstants.PATH_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.PATH_HEAD_SQ, tick);\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          ? GridConstants.PATH_FINISHED_WEIGHT_SQ\n          : GridConstants.PATH_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.PATH_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n    }\n  }\n  await wait(tick);\n  return Promise.resolve({ isAnimating: false, isAnimatingFinished: true });\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nexport default { animate };\n","import React, { useState } from 'react';\nimport './../styles/Grid.css';\nimport Square from './Square.js';\nimport Animations from './../services/Animations.js';\nimport GridConstants from './../services/GridConstants.js';\n\nconst Grid = ({\n  grid,\n  gridStyle,\n  setGrid,\n  startIsCovering,\n  setStartIsCovering,\n  endIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  isAnimatingFinished,\n  algorithm,\n}) => {\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isHoldingStart, setIsHoldingStart] = useState(false);\n  const [isHoldingEnd, setIsHoldingEnd] = useState(false);\n  const [isWDown, setIsWDown] = useState(false);\n\n  const updateGridOnMouseDown = (sq) => {\n    const nextGrid = [...grid];\n    if (grid[sq] === GridConstants.START_SQ) {\n      setIsHoldingStart(true);\n    } else if (grid[sq] === GridConstants.END_SQ) {\n      setIsHoldingEnd(true);\n    } else if (grid[sq] === GridConstants.WEIGHT_SQ) {\n      if (isWDown) {\n        nextGrid[sq] = GridConstants.DEFAULT_SQ;\n      } else {\n        nextGrid[sq] = GridConstants.WALL_SQ;\n      }\n    } else if (grid[sq] === GridConstants.WALL_SQ) {\n      if (isWDown) {\n        nextGrid[sq] = GridConstants.WEIGHT_SQ;\n      } else {\n        nextGrid[sq] = GridConstants.DEFAULT_SQ;\n      }\n    } else {\n      if (isWDown) {\n        nextGrid[sq] = GridConstants.WEIGHT_SQ;\n      } else {\n        nextGrid[sq] = GridConstants.WALL_SQ;\n      }\n    }\n    setGrid(nextGrid);\n  };\n\n  const updateGridOnMouseEnter = (sq) => {\n    const startSq = grid.findIndex((s) => s === GridConstants.START_SQ);\n    const endSq = grid.findIndex((s) => s === GridConstants.END_SQ);\n    if (isMouseDown && (sq !== startSq) & (sq !== endSq)) {\n      const nextGrid = [...grid];\n      if (isHoldingStart) {\n        nextGrid[startSq] = startIsCovering;\n        nextGrid[sq] = GridConstants.START_SQ;\n        setStartIsCovering(grid[sq]);\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none');\n          return;\n        }\n      } else if (isHoldingEnd) {\n        nextGrid[endSq] = endIsCovering;\n        nextGrid[sq] = GridConstants.END_SQ;\n        setEndIsCovering(grid[sq]);\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none');\n          return;\n        }\n      } else {\n        if (grid[sq] === GridConstants.WEIGHT_SQ) {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.DEFAULT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.WALL_SQ;\n          }\n        } else if (grid[sq] === GridConstants.WALL_SQ) {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.WEIGHT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.DEFAULT_SQ;\n          }\n        } else {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.WEIGHT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.WALL_SQ;\n          }\n        }\n      }\n      setGrid(nextGrid);\n    }\n  };\n\n  const onMouseEnter = (sq) => {\n    if (!isAnimating) {\n      updateGridOnMouseEnter(sq);\n    }\n  };\n\n  const onMouseDown = (sq) => {\n    if (!isAnimating) {\n      updateGridOnMouseDown(sq);\n      setIsMouseDown(true);\n    }\n  };\n\n  const onMouseUp = (sq) => {\n    if (!isAnimating) {\n      if (isHoldingStart) {\n        setIsHoldingStart(false);\n      } else if (isHoldingEnd) {\n        setIsHoldingEnd(false);\n      }\n      setIsMouseDown(false);\n    }\n  };\n\n  const onKeyDown = (e) => {\n    if (!isAnimating) {\n      if (e.key === 'w') {\n        setIsWDown(true);\n      }\n    }\n  };\n\n  const onKeyUp = (e) => {\n    if (!isAnimating) {\n      if (e.key === 'w') {\n        setIsWDown(false);\n      }\n    }\n  };\n\n  const renderSquare = (sqType, sq) => {\n    return (\n      <Square\n        key={sq}\n        id={sq}\n        className={sqType}\n        onMouseEnter={() => onMouseEnter(sq)}\n        onMouseDown={() => onMouseDown(sq)}\n        onMouseUp={() => onMouseUp(sq)}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n      />\n    );\n  };\n\n  const renderGrid = () => {\n    console.log('rendering grid');\n    console.log(grid[GridConstants.INITIAL_START]);\n    return grid.map((sqType, sq) => renderSquare(sqType, sq));\n  };\n\n  return (\n    <div style={gridStyle} className='grid'>\n      {renderGrid()}\n    </div>\n  );\n};\n\nexport default Grid;\n","import React from 'react';\nimport ReactSelect from 'react-select';\nimport './../styles/TopBar.css';\n\nconst Select = (props) => {\n  const customSelectStyle = {\n    menu: (provided, state) => ({\n      ...provided,\n      backgroundColor: 'rgb(17, 138, 178)',\n      width: '160px',\n      border: 'none',\n      margin: '0px',\n      padding: '0px',\n    }),\n    menuList: (provided, state) => ({\n      ...provided,\n      padding: '0px',\n      borderRadius: '0px 0px 5px 5px',\n    }),\n    container: (provided, state) => ({\n      ...provided,\n      height: '40px',\n      margin: 'auto 10px',\n      display: 'flex',\n      alignItems: 'center',\n    }),\n    control: (provided, state) => ({\n      ...provided,\n      width: '160px',\n      height: '100%',\n      border: 'none',\n      borderRadius: state.menuIsOpen ? '5px 5px 0px 0px' : '5px',\n      boxShadow: 'none',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n      fontSize: '20px',\n      cursor: 'pointer',\n      userSelect: 'none',\n\n      color: 'white',\n      backgroundColor:\n        state.hasValue || state.menuIsOpen\n          ? 'rgb(17, 138, 178)'\n          : 'transparent',\n      '&:hover': {\n        backgroundColor: 'rgb(17, 138, 178)',\n        color: 'white',\n        border: 'none',\n      },\n    }),\n    dropdownIndicator: (provided, state) => ({\n      margin: '3px',\n    }),\n    indicatorSeparator: (provided) => ({}),\n    placeholder: (provided, state) => ({}),\n    option: (provided, state) => ({\n      ...provided,\n      cursor: 'pointer',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n\n      color: 'white',\n      backgroundColor: 'rgb(17, 138, 178)',\n      '&:hover': {\n        color: 'rgb(38, 70, 83)',\n        backgroundColor: 'rgb(233, 196, 106)',\n      },\n    }),\n    singleValue: (provided) => ({\n      ...provided,\n      whiteSpace: 'nowrap',\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      paddingRight: '4px',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n      lineHeight: '36px',\n      top: '50%',\n      color: '',\n    }),\n    valueContainer: (provided) => ({\n      ...provided,\n      height: '100%',\n    }),\n  };\n\n  return (\n    <ReactSelect\n      styles={customSelectStyle}\n      options={props.options.map((option) => ({\n        value: option,\n        label: props.optionsMap[option],\n      }))}\n      value={\n        props.option && {\n          value: props.option,\n          label: props.optionsMap[props.option],\n        }\n      }\n      onChange={(data) => props.onChange(data.value)}\n      // onInputChange={(data) => props.onChange(data)}\n      placeholder={props.placeholder}\n      isSearchable={false}\n      tabSelectsValue={false}\n    />\n  );\n};\n\nexport default Select;\n","import GridConstants from './../services/GridConstants.js';\n\nconst generateMaze = async (maze, grid, setGrid, resetGrid, speed) => {\n  console.log('size', GridConstants.SIZE);\n  if (!maze) {\n    return Promise.resolve({ finished: false, grid: grid });\n  }\n  grid = new Array(GridConstants.SIZE).fill(GridConstants.DEFAULT_SQ);\n  setGrid(grid);\n\n  let delay = 10;\n  switch (maze) {\n    case 'random':\n      return await randomMaze(grid, setGrid, 0, delay);\n    case 'dfs':\n      return await dfs(grid, setGrid, 0, delay);\n    case 'recursiveDivision':\n      return await recursiveDivision(grid, setGrid, 0, delay);\n    case 'kruskal':\n      return await kruskal(grid, setGrid, 0, delay);\n    case 'prim':\n      return await prim(grid, setGrid, 0, delay);\n    default:\n  }\n};\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst drawRow = (grid, setGrid, tick, delay, row, colRange) => {\n  for (let i = colRange[0]; i <= colRange[1]; i++, tick += delay) {\n    const sq = row * GridConstants.WIDTH + i;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawCol = (grid, setGrid, tick, delay, col, rowRange) => {\n  for (let i = rowRange[0]; i <= rowRange[1]; i++, tick += delay) {\n    const sq = i * GridConstants.WIDTH + col;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawMazeBorder = (grid, setGrid, tick, delay) => {\n  console.log(tick);\n  for (let i = 0; i < GridConstants.WIDTH; i++, tick += delay) {\n    const topRow = GridConstants.getSq(0, i);\n    const bottomRow = GridConstants.getSq(GridConstants.HEIGHT - 1, i);\n    grid = changeSquare(grid, setGrid, topRow, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, bottomRow, GridConstants.WALL_SQ, tick);\n  }\n  for (let i = 0; i < GridConstants.HEIGHT; i++, tick += delay) {\n    const leftCol = GridConstants.getSq(i, 0);\n    const rightCol = GridConstants.getSq(i, GridConstants.WIDTH - 1);\n    grid = changeSquare(grid, setGrid, leftCol, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, rightCol, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst generateWallGrid = (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let row = 1; row < GridConstants.HEIGHT - 1; row++) {\n    for (let col = 1; col < GridConstants.WIDTH - 1; col++) {\n      if (!(row % 2 && col % 2)) {\n        grid[GridConstants.getSq(row, col)] = GridConstants.WALL_SQ;\n      }\n    }\n  }\n  setTimeout(() => {\n    setGrid(grid);\n  }, tick);\n  return [tick, [...grid]];\n};\n\nconst getRandomNumberBetween = (start, end) => {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n};\n\nconst getRandomElement = (array) => {\n  return array.splice(getRandomNumberBetween(0, array.length - 1), 1)[0];\n};\n\nconst shuffleArray = (array) => {\n  const newArray = [];\n  while (array.length > 0) {\n    newArray.push(getRandomElement(array));\n  }\n  return newArray;\n};\n\nconst getClosestEmptyTileFrom = (grid, from) => {\n  return grid.reduce((closest, sq, idx) => {\n    if (sq === GridConstants.DEFAULT_SQ) {\n      if (closest === -1) {\n        return idx;\n      } else {\n        const closestDist = GridConstants.dist(from, closest);\n        const sqDist = GridConstants.dist(from, idx);\n        return sqDist < closestDist ? idx : closest;\n      }\n    } else {\n      return closest;\n    }\n  }, -1);\n};\n\nconst generateStartEndPosition = (\n  grid,\n  setGrid,\n  idealStart,\n  idealEnd,\n  delay\n) => {\n  const start = getClosestEmptyTileFrom(grid, idealStart);\n  const end = getClosestEmptyTileFrom(grid, idealEnd);\n  grid = changeSquare(grid, setGrid, start, GridConstants.START_SQ, delay);\n  return changeSquare(grid, setGrid, end, GridConstants.END_SQ, delay);\n};\n\nconst randomMaze = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  console.log(tick);\n  for (let i = 0; i < grid.length; i++) {\n    if (GridConstants.validMazeMove(i, i) && Math.random() < 0.35) {\n      grid[i] = GridConstants.WALL_SQ;\n    }\n  }\n  setTimeout(() => setGrid(grid), tick);\n\n  grid = [...grid];\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(0, 0),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst dfs = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  const start = GridConstants.getSq(1, 1);\n  const visited = new Set([start]);\n  const path = [start];\n  while (path.length > 0) {\n    const currSquare = path.pop();\n    let moves = [-2, 2, -2 * GridConstants.WIDTH, 2 * GridConstants.WIDTH];\n    moves = moves.filter((move) =>\n      GridConstants.validMazeMove(currSquare, currSquare + move)\n    );\n\n    while (moves.length > 0) {\n      const nextMove =\n        currSquare + moves.splice(Math.random() * moves.length, 1)[0];\n      const nextMoves = [(currSquare + nextMove) / 2, nextMove];\n      if (!visited.has(nextMove)) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[0],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[1],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        visited.add(nextMove);\n        path.push(nextMove);\n        path.push(nextMove);\n        break;\n      }\n    }\n  }\n\n  // place end as far away as possible from start\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst recursiveDivision = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n\n  [tick, grid] = divide(\n    grid,\n    setGrid,\n    tick,\n    delay,\n    [0, GridConstants.HEIGHT - 1],\n    [0, GridConstants.WIDTH - 1]\n  );\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst divide = (grid, setGrid, tick, delay, rowRange, colRange) => {\n  const [possibleRows, possibleRowHoles] = [[], []];\n  const [possibleCols, possibleColHoles] = [[], []];\n  for (let i = rowRange[0] + 1; i < rowRange[1]; i++) {\n    if ((i - rowRange[0]) % 2 === 0) {\n      possibleRows.push(i);\n    } else {\n      possibleRowHoles.push(i);\n    }\n  }\n  for (let i = colRange[0] + 1; i < colRange[1]; i++) {\n    if ((i - colRange[0]) % 2 === 0) {\n      possibleCols.push(i);\n    } else {\n      possibleColHoles.push(i);\n    }\n  }\n\n  if (possibleRows.length === 0 || possibleCols.length === 0) {\n    return [tick, grid];\n  } else {\n    if (possibleRows.length >= possibleCols.length) {\n      const randomRow = getRandomElement(possibleRows);\n      [tick, grid] = drawRow(grid, setGrid, tick, delay, randomRow, colRange);\n      const randomColHole = getRandomElement(possibleColHoles);\n      const randomHole = randomRow * GridConstants.WIDTH + randomColHole;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [rowRange[0], randomRow],\n        colRange\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [randomRow, rowRange[1]],\n        colRange\n      );\n    } else {\n      let randomCol = getRandomElement(possibleCols);\n      [tick, grid] = drawCol(grid, setGrid, tick, delay, randomCol, rowRange);\n      const randomRowHole = getRandomElement(possibleRowHoles);\n      const randomHole = randomRowHole * GridConstants.WIDTH + randomCol;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        colRange[0],\n        randomCol,\n      ]);\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        randomCol,\n        colRange[1],\n      ]);\n    }\n    return [tick, grid];\n  }\n};\n\nconst kruskal = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let treeSet = {};\n  let wallMap = {};\n\n  // fill wallMap and treeSet\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    const [iRow, iCol] = GridConstants.getCoor(i);\n    if (GridConstants.validMazeMove(i, i)) {\n      if (iRow % 2 && iCol % 2) {\n        treeSet[i] = new Set([i]);\n      } else {\n        if (iCol % 2) {\n          wallMap[i] = [i - GridConstants.WIDTH, i + GridConstants.WIDTH];\n        } else if (iRow % 2) {\n          wallMap[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  for (const [wall, [sq1, sq2]] of shuffleArray(Object.entries(wallMap))) {\n    if (!treeSet[sq1].has(sq2)) {\n      grid = changeSquare(\n        grid,\n        setGrid,\n        wall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      const union = new Set([...treeSet[sq1], ...treeSet[sq2]]);\n      treeSet[sq1].forEach((sq) => (treeSet[sq] = union));\n      treeSet[sq2].forEach((sq) => (treeSet[sq] = union));\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst prim = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let neighborSquares = {};\n  let neighborWalls = {};\n\n  // fill walls\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    if (GridConstants.validMazeMove(i, i)) {\n      const [iRow, iCol] = GridConstants.getCoor(i);\n      if (iRow % 2 && iCol % 2) {\n        const t = GridConstants.validMazeMove(i, i - GridConstants.WIDTH)\n          ? [i - GridConstants.WIDTH]\n          : [];\n        const r = GridConstants.validMazeMove(i, i + 1) ? [i + 1] : [];\n        const b = GridConstants.validMazeMove(i, i + GridConstants.WIDTH)\n          ? [i + GridConstants.WIDTH]\n          : [];\n        const l = GridConstants.validMazeMove(i, i - 1) ? [i - 1] : [];\n        neighborWalls[i] = [...t, ...r, ...b, ...l];\n      } else if (iRow % 2 ^ iCol % 2) {\n        if (iCol % 2) {\n          neighborSquares[i] = [\n            i - GridConstants.WIDTH,\n            i + GridConstants.WIDTH,\n          ];\n        } else if (iRow % 2) {\n          neighborSquares[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  const visitedSquares = new Set([GridConstants.getSq(1, 1)]);\n  let visitedWalls = [...neighborWalls[GridConstants.getSq(1, 1)]];\n  while (visitedWalls.length > 0) {\n    const randomWall = getRandomElement(visitedWalls);\n    const [sq1, sq2] = neighborSquares[randomWall];\n    if (sq1 > GridConstants.SIZE || sq2 > GridConstants.SIZE) {\n    }\n    if (visitedSquares.has(sq1) ^ visitedSquares.has(sq2)) {\n      if (!visitedSquares.has(sq1)) {\n        visitedSquares.add(sq1);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq1]];\n      } else {\n        visitedSquares.add(sq2);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq2]];\n      }\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomWall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nexport default { generateMaze };\n","import React from 'react';\nimport Select from './Select';\nimport './../styles/TopBar.css';\nimport Animations from './../services/Animations.js';\nimport Maze from './../services/Maze.js';\nimport GridConstants from './../services/GridConstants.js';\n\nconst TopBar = ({\n  grid,\n  setGrid,\n  resetGrid,\n  setStartIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  setIsAnimating,\n  setIsAnimatingFinished,\n  algorithm,\n  setAlgorithm,\n  maze,\n  setMaze,\n  speed,\n  setSpeed,\n}) => {\n  const handleAlgorithmSubmit = async (event) => {\n    event.preventDefault();\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Animations.animate(algorithm, grid, setGrid, speed);\n      setIsAnimating(promise.isAnimating);\n      setIsAnimatingFinished(promise.isAnimatingFinished);\n    }\n  };\n\n  const handleMazeSubmit = async (maze) => {\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Maze.generateMaze(maze, grid, setGrid, resetGrid);\n      setMaze(null);\n      setStartIsCovering(GridConstants.DEFAULT_SQ);\n      setEndIsCovering(GridConstants.DEFAULT_SQ);\n      setIsAnimating(promise.finished);\n      setIsAnimatingFinished(false);\n    }\n  };\n\n  const onAlgorithmChange = (alg) => {\n    setAlgorithm(alg);\n  };\n\n  const onMazeChange = (maze) => {\n    setMaze(maze);\n    handleMazeSubmit(maze);\n  };\n\n  const onSpeedChange = (speed) => {\n    setSpeed(speed);\n  };\n\n  const handleResetClick = (e) => {\n    if (!isAnimating) {\n      e.preventDefault();\n      resetGrid();\n    }\n  };\n\n  const algorithmsMap = {\n    dijkstra: 'Dijkstra',\n    astar: 'A* Search',\n    greedy: 'Greedy BFS',\n    dfs: 'DFS',\n    bfs: 'BFS',\n  };\n  const algorithmsPlaceholder = 'Algorithm';\n\n  const mazesMap = {\n    random: 'Random',\n    dfs: 'DFS',\n    recursiveDivision: 'Recursive Division',\n    kruskal: 'Kruskal',\n    prim: 'Prim',\n  };\n  const mazePlaceholder = 'Maze';\n\n  const speedMap = {\n    slow: 'Slow',\n    medium: 'Medium',\n    fast: 'Fast',\n  };\n  const speedPlaceholder = 'Speed';\n\n  return (\n    <div className='topBar'>\n      <h1 className='title'>Path Visualizer</h1>\n      <div className='optionsContainer'>\n        <div className='topBarItemContainer'>\n          <Select\n            option={algorithm}\n            onChange={onAlgorithmChange}\n            options={Object.keys(algorithmsMap)}\n            optionsMap={algorithmsMap}\n            placeholder={algorithmsPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={speed}\n            onChange={onSpeedChange}\n            options={Object.keys(speedMap)}\n            optionsMap={speedMap}\n            placeholder={speedPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={maze}\n            onChange={onMazeChange}\n            options={Object.keys(mazesMap)}\n            optionsMap={mazesMap}\n            placeholder={mazePlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <button\n            className={\n              isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton'\n            }\n            onClick={handleAlgorithmSubmit}>\n            Visualize\n          </button>\n          <button\n            className={\n              (isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton') +\n              ' resetButton'\n            }\n            onClick={handleResetClick}>\n            Reset\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TopBar;\n","import React from 'react';\nimport './../styles/Legend.css';\n\nconst Legend = ({ name, img }) => {\n  return (\n    <span className='legendContainer'>\n      <span className={`legend ${name}Legend`}>\n        {img && (\n          <img className='legendImg' src={img} alt={img} draggable='false' />\n        )}\n      </span>\n      <span className='legendText'>{name}</span>\n    </span>\n  );\n};\n\nexport default Legend;\n","import React, { useState, useEffect } from 'react';\nimport Grid from './Grid.js';\nimport TopBar from './TopBar.js';\nimport Legend from './Legend.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/App.css';\n\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\n\nfunction App() {\n  const [grid, setGrid] = useState(GridConstants.INITIAL_GRID);\n  const [startIsCovering, setStartIsCovering] = useState(\n    GridConstants.DEFAULT_SQ\n  );\n  const [endIsCovering, setEndIsCovering] = useState(GridConstants.DEFAULT_SQ);\n  const [algorithm, setAlgorithm] = useState(null);\n  const [speed, setSpeed] = useState('fast');\n  const [maze, setMaze] = useState(null);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isAnimatingFinished, setIsAnimatingFinished] = useState(false);\n\n  const resetGrid = () => {\n    setGrid(GridConstants.INITIAL_GRID);\n    setIsAnimatingFinished(false);\n    setStartIsCovering(GridConstants.DEFAULT_SQ);\n    setEndIsCovering(GridConstants.DEFAULT_SQ);\n    setAlgorithm(null);\n    setMaze(null);\n    setSpeed('fast');\n  };\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (!isAnimating) {\n        GridConstants.update(\n          Math.floor((window.innerWidth - 25) / 25),\n          Math.floor((window.innerHeight - 150) / 25)\n        );\n        resetGrid();\n      }\n    };\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, [isAnimating]);\n\n  const legends = [\n    {\n      name: 'Start',\n      img: start,\n    },\n    {\n      name: 'End',\n      img: end,\n    },\n    {\n      name: 'Weight',\n      img: weight,\n    },\n    {\n      name: 'Wall',\n    },\n    {\n      name: 'Visited',\n    },\n    {\n      name: 'Path',\n    },\n  ];\n\n  const gridStyle = {\n    gridTemplateColumns: `repeat(${GridConstants.WIDTH}, 25px)`,\n    gridTemplateRows: `repeat(${GridConstants.HEIGHT}, 25px)`,\n  };\n\n  return (\n    <div className='page'>\n      <TopBar\n        grid={grid}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        setStartIsCovering={setStartIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        setIsAnimating={setIsAnimating}\n        setIsAnimatingFinished={setIsAnimatingFinished}\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        speed={speed}\n        setSpeed={setSpeed}\n        maze={maze}\n        setMaze={setMaze}\n      />\n      <div className='legendsContainer'>\n        {legends.map((legend) => (\n          <Legend key={legend.name} name={legend.name} img={legend.img} />\n        ))}\n      </div>\n      <Grid\n        grid={grid}\n        gridStyle={gridStyle}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        startIsCovering={startIsCovering}\n        setStartIsCovering={setStartIsCovering}\n        endIsCovering={endIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        isAnimatingFinished={isAnimatingFinished}\n        algorithm={algorithm}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App className='page' />, document.getElementById('root'));\n"],"sourceRoot":""}