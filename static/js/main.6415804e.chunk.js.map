{"version":3,"sources":["images/weight.png","images/start.png","images/end.png","images/weight.svg","images/start.svg","images/end.svg","services/GridConstants.js","components/Square.js","services/Algorithms.js","services/Animations.js","components/Grid.js","components/Select.js","services/Maze.js","components/TopBar.js","components/Legend.js","components/App.js","index.js"],"names":["module","exports","WIDTH","HEIGHT","SIZE","INITIAL_START","INITIAL_END","INITIAL_GRID","getRow","getCol","getCoor","getSq","dist","validMove","validMazeMove","GridConstants","DEFAULT_SQ","START_SQ","END_SQ","WALL_SQ","WEIGHT_SQ","VISITED_SQ","VISITED_WEIGHT_SQ","VISITED_HEAD_SQ","VISITED_FINISHED_SQ","VISITED_FINISHED_WEIGHT_SQ","PATH_SQ","PATH_WEIGHT_SQ","PATH_HEAD_SQ","PATH_FINISHED_SQ","PATH_FINISHED_WEIGHT_SQ","update","width","height","Math","floor","Array","fill","sq","row","col","start","end","abs","endRow","endCol","window","innerWidth","innerHeight","React","memo","props","console","log","id","className","onMouseEnter","onMouseDown","onMouseUp","onKeyDown","onKeyUp","tabIndex","src","weight","draggable","alt","prev","next","grid","findIndex","visited","weights","Number","MAX_SAFE_INTEGER","pq","currSquare","shift","push","moves","map","move","filter","nextSquare","moveWeight","includes","splice","indexOf","inserted","i","length","path","unshift","heuristic","count","stack","pop","queue","clearAnimate","setGrid","nextGrid","animate","algorithm","speed","a","Promise","resolve","isAnimating","isAnimatingFinished","pathDelay","visitedDelay","Algorithms","square","tick","prevSquare","squareType","changeSquare","ind","wait","ms","setTimeout","delay","gridStyle","startIsCovering","setStartIsCovering","endIsCovering","setEndIsCovering","useState","isMouseDown","setIsMouseDown","isHoldingStart","setIsHoldingStart","isHoldingEnd","setIsHoldingEnd","isWDown","setIsWDown","mouseIsOver","setMouseIsOver","useEffect","updateGridOnMouseDown","startSq","s","endSq","Animations","updateGridOnMouseEnter","useCallback","e","key","style","sqType","renderSquare","Select","customSelectStyle","menu","provided","state","backgroundColor","border","margin","padding","menuList","borderRadius","container","display","alignItems","control","menuIsOpen","boxShadow","fontFamily","fontWeight","fontSize","cursor","userSelect","color","hasValue","dropdownIndicator","indicatorSeparator","placeholder","option","singleValue","whiteSpace","overflow","textOverflow","paddingRight","maxWidth","lineHeight","top","valueContainer","styles","options","value","label","optionsMap","onChange","data","isSearchable","tabSelectsValue","generateMaze","maze","resetGrid","finished","randomMaze","dfs","recursiveDivision","kruskal","prim","drawMazeBorder","topRow","bottomRow","leftCol","rightCol","generateWallGrid","getRandomElement","array","random","shuffleArray","newArray","getClosestEmptyTileFrom","from","reduce","closest","idx","closestDist","generateStartEndPosition","idealStart","idealEnd","Set","nextMove","nextMoves","has","add","divide","rowRange","colRange","possibleRows","possibleRowHoles","possibleCols","possibleColHoles","randomRow","drawRow","randomColHole","randomHole","randomCol","drawCol","treeSet","wallMap","iRow","iCol","Object","entries","wall","sq1","sq2","union","forEach","neighborSquares","neighborWalls","t","r","b","l","visitedSquares","visitedWalls","randomWall","TopBar","setIsAnimating","setIsAnimatingFinished","setAlgorithm","setMaze","setSpeed","handleAlgorithmSubmit","event","preventDefault","promise","handleMazeSubmit","Maze","algorithmsMap","dijkstra","astar","greedy","bfs","mazesMap","speedMap","slow","medium","fast","alg","keys","onClick","Legend","name","img","App","isAnimatingRef","useRef","current","topBarHeight","document","getElementsByClassName","offsetHeight","legendsHeight","updateDimensions","addEventListener","removeEventListener","legends","gridTemplateColumns","gridTemplateRows","legend","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.6415804e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.e1848324.png\";","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/end.9d61b99b.png\";","module.exports = __webpack_public_path__ + \"static/media/weight.f8a5f7dd.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.ff2b9671.svg\";","module.exports = __webpack_public_path__ + \"static/media/end.93326d55.svg\";","let GridConstants = {};\nlet WIDTH,\n  HEIGHT,\n  SIZE,\n  INITIAL_START,\n  INITIAL_END,\n  INITIAL_GRID,\n  getRow,\n  getCol,\n  getCoor,\n  getSq,\n  dist,\n  validMove,\n  validMazeMove;\n\nGridConstants.DEFAULT_SQ = 'square';\nGridConstants.START_SQ = 'startSquare';\nGridConstants.END_SQ = 'endSquare';\nGridConstants.WALL_SQ = 'wallSquare';\nGridConstants.WEIGHT_SQ = 'weightSquare';\nGridConstants.VISITED_SQ = 'visitedSquare';\nGridConstants.VISITED_WEIGHT_SQ = 'visitedWeightSquare';\nGridConstants.VISITED_HEAD_SQ = 'visitedHeadSquare';\nGridConstants.VISITED_FINISHED_SQ = 'visitedFinishedSquare';\nGridConstants.VISITED_FINISHED_WEIGHT_SQ = 'visitedFinishedWeightSquare';\nGridConstants.PATH_SQ = 'pathSquare';\nGridConstants.PATH_WEIGHT_SQ = 'pathWeightSquare';\nGridConstants.PATH_HEAD_SQ = 'pathHeadSquare';\nGridConstants.PATH_FINISHED_SQ = 'pathFinishedSquare';\nGridConstants.PATH_FINISHED_WEIGHT_SQ = 'pathFinishedWeightSquare';\n\nconst update = (width, height) => {\n  WIDTH = width;\n  HEIGHT = height;\n\n  // maintain odd number of rows and cols for maze\n  if (WIDTH % 2 === 0) {\n    WIDTH--;\n  }\n  if (HEIGHT % 2 === 0) {\n    HEIGHT--;\n  }\n  SIZE = WIDTH * HEIGHT;\n  INITIAL_START = (Math.floor(HEIGHT / 2) - 1) * WIDTH + Math.floor(WIDTH / 6);\n  INITIAL_END =\n    (Math.floor(HEIGHT / 2) - 1) * WIDTH + Math.floor((WIDTH * 5) / 6);\n  INITIAL_GRID = new Array(SIZE).fill(GridConstants.DEFAULT_SQ);\n  INITIAL_GRID[INITIAL_START] = GridConstants.START_SQ;\n  INITIAL_GRID[INITIAL_END] = GridConstants.END_SQ;\n\n  getRow = (sq) => Math.floor(sq / WIDTH);\n\n  getCol = (sq) => sq % WIDTH;\n\n  getCoor = (sq) => [getRow(sq), getCol(sq)];\n\n  getSq = (row, col) => row * WIDTH + col;\n\n  dist = (start, end) =>\n    Math.abs(getRow(start) - getRow(end)) +\n    Math.abs(getCol(start) - getCol(end));\n\n  validMove = (start, end) =>\n    end < SIZE && end >= 0 && Math.abs(getCol(end) - getCol(start)) <= 2;\n\n  validMazeMove = (start, end) => {\n    const [endRow, endCol] = getCoor(end);\n    return (\n      endRow >= 1 &&\n      endRow < HEIGHT - 1 &&\n      endCol >= 1 &&\n      endCol < WIDTH - 1 &&\n      validMove(start, end)\n    );\n  };\n\n  GridConstants.WIDTH = WIDTH;\n  GridConstants.HEIGHT = HEIGHT;\n  GridConstants.SIZE = SIZE;\n  GridConstants.INITIAL_START = INITIAL_START;\n  GridConstants.INITIAL_END = INITIAL_END;\n  GridConstants.INITIAL_GRID = INITIAL_GRID;\n  GridConstants.getRow = getRow;\n  GridConstants.getCol = getCol;\n  GridConstants.getCoor = getCoor;\n  GridConstants.getSq = getSq;\n  GridConstants.dist = dist;\n  GridConstants.validMove = validMove;\n  GridConstants.validMazeMove = validMazeMove;\n  GridConstants.update = update;\n};\n\nupdate(\n  Math.floor((window.innerWidth - 50) / 25),\n  Math.floor((window.innerHeight - 150) / 25)\n);\n\nexport default GridConstants;\n","import React from 'react';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/Square.css';\n\nimport weight from './../images/weight.png';\nimport start from './../images/start.png';\nimport end from './../images/end.png';\n\nconst Square = (props) => {\n  console.log('rendering');\n  return (\n    <div\n      id={props.id}\n      className={props.className}\n      onMouseEnter={props.onMouseEnter}\n      onMouseDown={props.onMouseDown}\n      onMouseUp={props.onMouseUp}\n      onKeyDown={props.onKeyDown}\n      onKeyUp={props.onKeyUp}\n      tabIndex={-1}>\n      {(props.className === GridConstants.WEIGHT_SQ ||\n        props.className === GridConstants.VISITED_WEIGHT_SQ ||\n        props.className === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n        props.className === GridConstants.PATH_WEIGHT_SQ ||\n        props.className === GridConstants.PATH_FINISHED_WEIGHT_SQ) && (\n        <img\n          src={weight}\n          className='weightImg'\n          draggable='false'\n          alt='weight'\n        />\n      )}\n      {(props.className === GridConstants.START_SQ ||\n        props.className === GridConstants.PATH_HEAD_SQ) && (\n        <img src={start} className='startImg' draggable='false' alt='start' />\n      )}\n      {props.className === GridConstants.END_SQ && (\n        <img src={end} className='endImg' draggable='false' alt='end' />\n      )}\n    </div>\n  );\n};\n\nconst areEqual = (prev, next) => {\n  if (prev.className !== next.className)\n    console.log(prev.className, next.className);\n  return prev.className === next.className;\n};\n\nexport default React.memo(Square, areEqual);\n// export default React.memo(Square);\n","import GridConstants from './../services/GridConstants.js';\n\nconst dijkstra = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (moveWeight < weights[pq[i]]) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  while (currSquare || currSquare === 0) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst astar = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const heuristic = (start, end) => {\n    return (\n      Math.abs(\n        Math.floor(start / GridConstants.WIDTH) -\n          Math.floor(end / GridConstants.WIDTH)\n      ) + Math.abs((start % GridConstants.WIDTH) - (end % GridConstants.WIDTH))\n    );\n  };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (\n              moveWeight + heuristic(nextSquare, end) <\n              weights[pq[i]] + heuristic(pq[i], end)\n            ) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  let path = [];\n  let currSquare = end;\n  while (currSquare || currSquare === 0) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n\n  return [visited, path];\n};\n\nconst greedy = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = { start: 1 };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = GridConstants.dist(nextSquare, end);\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      }\n\n      // insert into priority queue\n      if (!pq.includes(nextSquare) && !visited.includes(nextSquare)) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n        let inserted = false;\n        for (let i = 0; i < pq.length; i++) {\n          if (moveWeight < weights[pq[i]]) {\n            pq.splice(i, 0, nextSquare);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          pq.push(nextSquare);\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare || currSquare === 0) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst dfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const stack = [start];\n  while (stack.length > 0) {\n    const currSquare = stack.pop();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into stack\n      if (!visited.includes(nextSquare) && !stack.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        stack.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare || currSquare === 0) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst bfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const queue = [start];\n  while (queue.length > 0) {\n    const currSquare = queue.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into queue\n      if (!visited.includes(nextSquare) && !queue.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        queue.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare || currSquare === 0) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nexport default { dijkstra, astar, greedy, dfs, bfs };\n","import GridConstants from './../services/GridConstants.js';\nimport Algorithms from './Algorithms';\n\nconst clearAnimate = (grid, setGrid) => {\n  const nextGrid = grid.map((sq) => {\n    if (\n      sq === GridConstants.START_SQ ||\n      sq === GridConstants.END_SQ ||\n      sq === GridConstants.WALL_SQ\n    ) {\n      return sq;\n    } else if (\n      sq === GridConstants.WEIGHT_SQ ||\n      sq === GridConstants.VISITED_WEIGHT_SQ ||\n      sq === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n      sq === GridConstants.PATH_WEIGHT_SQ ||\n      sq === GridConstants.PATH_FINISHED_WEIGHT_SQ\n    ) {\n      return GridConstants.WEIGHT_SQ;\n    } else {\n      return GridConstants.DEFAULT_SQ;\n    }\n  });\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst animate = async (algorithm, grid, setGrid, speed) => {\n  if (!algorithm || !speed) {\n    return Promise.resolve({ isAnimating: false, isAnimatingFinished: false });\n  }\n\n  let pathDelay = 50;\n  let visitedDelay;\n  switch (speed) {\n    case 'none':\n      break;\n    case 'slow':\n      visitedDelay = 70;\n      break;\n    case 'medium':\n      visitedDelay = 50;\n      break;\n    case 'fast':\n      visitedDelay = 30;\n      break;\n    default:\n  }\n\n  grid = clearAnimate(grid, setGrid);\n  let visited, path;\n  switch (algorithm) {\n    case 'dijkstra':\n      [visited, path] = Algorithms.dijkstra(grid);\n      break;\n    case 'astar':\n      [visited, path] = Algorithms.astar(grid);\n      break;\n    case 'greedy':\n      [visited, path] = Algorithms.greedy(grid);\n      break;\n    case 'dfs':\n      [visited, path] = Algorithms.dfs(grid);\n      break;\n    case 'bfs':\n      [visited, path] = Algorithms.bfs(grid);\n      break;\n    default:\n  }\n\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n  visited = visited.filter((square) => square !== start && square !== end);\n  path = path.filter((square) => square !== start && square !== end);\n\n  // animate visited\n  let tick = 0;\n  let prevSquare = null;\n  for (const square of visited) {\n    if (speed !== 'none') {\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_WEIGHT_SQ\n          : GridConstants.VISITED_SQ;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        square,\n        squareType,\n        (tick += visitedDelay)\n      );\n    } else {\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          : GridConstants.VISITED_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n\n  // animate path\n  prevSquare = null;\n  for (const square of path) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += pathDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_WEIGHT_SQ\n          ? GridConstants.PATH_WEIGHT_SQ\n          : GridConstants.PATH_SQ;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        square,\n        GridConstants.PATH_HEAD_SQ,\n        tick\n      );\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          ? GridConstants.PATH_FINISHED_WEIGHT_SQ\n          : GridConstants.PATH_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.PATH_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n    }\n  }\n  await wait(tick);\n  return Promise.resolve({ isAnimating: false, isAnimatingFinished: true });\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nexport default { animate };\n","import React, { useState, useEffect, useCallback } from 'react';\nimport Square from './Square.js';\nimport Animations from './../services/Animations.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/Grid.css';\n\nconst Grid = ({\n  grid,\n  gridStyle,\n  setGrid,\n  startIsCovering,\n  setStartIsCovering,\n  endIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  isAnimatingFinished,\n  algorithm,\n}) => {\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isHoldingStart, setIsHoldingStart] = useState(false);\n  const [isHoldingEnd, setIsHoldingEnd] = useState(false);\n  const [isWDown, setIsWDown] = useState(false);\n  const [mouseIsOver, setMouseIsOver] = useState(null);\n\n  useEffect(() => {\n    const updateGridOnMouseDown = (sq) => {\n      if (!isAnimating && isMouseDown) {\n        const nextGrid = [...grid];\n        if (grid[sq] === GridConstants.START_SQ) {\n          setIsHoldingStart(true);\n        } else if (grid[sq] === GridConstants.END_SQ) {\n          setIsHoldingEnd(true);\n        } else if (grid[sq] === GridConstants.WEIGHT_SQ) {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.DEFAULT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.WALL_SQ;\n          }\n        } else if (grid[sq] === GridConstants.WALL_SQ) {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.WEIGHT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.DEFAULT_SQ;\n          }\n        } else {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.WEIGHT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.WALL_SQ;\n          }\n        }\n        setGrid(nextGrid);\n      }\n    };\n    updateGridOnMouseDown(mouseIsOver);\n  }, [isMouseDown, isAnimating]);\n\n  useEffect(() => {\n    const updateGridOnMouseEnter = (sq) => {\n      const startSq = grid.findIndex((s) => s === GridConstants.START_SQ);\n      const endSq = grid.findIndex((s) => s === GridConstants.END_SQ);\n      if (!isAnimating && isMouseDown && (sq !== startSq) & (sq !== endSq)) {\n        const nextGrid = [...grid];\n        if (isHoldingStart) {\n          nextGrid[startSq] = startIsCovering;\n          nextGrid[sq] = GridConstants.START_SQ;\n          setStartIsCovering(grid[sq]);\n          if (isAnimatingFinished) {\n            Animations.animate(algorithm, nextGrid, setGrid, 'none');\n            return;\n          }\n        } else if (isHoldingEnd) {\n          nextGrid[endSq] = endIsCovering;\n          nextGrid[sq] = GridConstants.END_SQ;\n          setEndIsCovering(grid[sq]);\n          if (isAnimatingFinished) {\n            Animations.animate(algorithm, nextGrid, setGrid, 'none');\n            return;\n          }\n        } else {\n          if (grid[sq] === GridConstants.WEIGHT_SQ) {\n            if (isWDown) {\n              nextGrid[sq] = GridConstants.DEFAULT_SQ;\n            } else {\n              nextGrid[sq] = GridConstants.WALL_SQ;\n            }\n          } else if (grid[sq] === GridConstants.WALL_SQ) {\n            if (isWDown) {\n              nextGrid[sq] = GridConstants.WEIGHT_SQ;\n            } else {\n              nextGrid[sq] = GridConstants.DEFAULT_SQ;\n            }\n          } else {\n            if (isWDown) {\n              nextGrid[sq] = GridConstants.WEIGHT_SQ;\n            } else {\n              nextGrid[sq] = GridConstants.WALL_SQ;\n            }\n          }\n        }\n        setGrid(nextGrid);\n      }\n    };\n    updateGridOnMouseEnter(mouseIsOver);\n  }, [mouseIsOver, isAnimating]);\n\n  const onMouseEnter = useCallback((sq) => {\n    setMouseIsOver(sq);\n  }, []);\n\n  const onMouseDown = useCallback((sq) => {\n    setIsMouseDown(true);\n  }, []);\n\n  const onMouseUp = useCallback((sq) => {\n    setIsHoldingStart(false);\n    setIsHoldingEnd(false);\n    setIsMouseDown(false);\n  }, []);\n\n  const onKeyDown = useCallback((e) => {\n    if (e.key === 'w') {\n      setIsWDown(true);\n    }\n  }, []);\n\n  const onKeyUp = useCallback((e) => {\n    if (e.key === 'w') {\n      setIsWDown(false);\n    }\n  }, []);\n\n  const renderSquare = (sq) => {\n    return (\n      <Square\n        id={sq}\n        key={sq}\n        className={grid[sq]}\n        onMouseEnter={() => onMouseEnter(sq)}\n        onMouseDown={() => onMouseDown(sq)}\n        onMouseUp={() => onMouseUp(sq)}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n      />\n    );\n  };\n\n  const renderGrid = () => {\n    return grid.map((sqType, sq) => renderSquare(sq));\n  };\n\n  return (\n    <div style={gridStyle} className='grid'>\n      {renderGrid()}\n    </div>\n  );\n};\n\nexport default React.memo(Grid);\n","import React from 'react';\nimport ReactSelect from 'react-select';\nimport './../styles/TopBar.css';\n\nconst Select = (props) => {\n  const customSelectStyle = {\n    menu: (provided, state) => ({\n      ...provided,\n      backgroundColor: 'rgb(17, 138, 178)',\n      width: '160px',\n      border: 'none',\n      margin: '0px',\n      padding: '0px',\n    }),\n    menuList: (provided, state) => ({\n      ...provided,\n      padding: '0px',\n      borderRadius: '0px 0px 5px 5px',\n    }),\n    container: (provided, state) => ({\n      ...provided,\n      height: '40px',\n      margin: 'auto 10px',\n      display: 'flex',\n      alignItems: 'center',\n    }),\n    control: (provided, state) => ({\n      ...provided,\n      width: '160px',\n      height: '100%',\n      border: 'none',\n      borderRadius: state.menuIsOpen ? '5px 5px 0px 0px' : '5px',\n      boxShadow: 'none',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n      fontSize: '20px',\n      cursor: 'pointer',\n      userSelect: 'none',\n\n      color: 'white',\n      backgroundColor:\n        state.hasValue || state.menuIsOpen\n          ? 'rgb(17, 138, 178)'\n          : 'transparent',\n      '&:hover': {\n        backgroundColor: 'rgb(17, 138, 178)',\n        color: 'white',\n        border: 'none',\n      },\n    }),\n    dropdownIndicator: (provided, state) => ({\n      margin: '3px',\n    }),\n    indicatorSeparator: (provided) => ({}),\n    placeholder: (provided, state) => ({}),\n    option: (provided, state) => ({\n      ...provided,\n      cursor: 'pointer',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n\n      color: 'white',\n      backgroundColor: 'rgb(17, 138, 178)',\n      '&:hover': {\n        color: 'rgb(38, 70, 83)',\n        backgroundColor: 'rgb(233, 196, 106)',\n      },\n    }),\n    singleValue: (provided) => ({\n      ...provided,\n      whiteSpace: 'nowrap',\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      paddingRight: '4px',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n      lineHeight: '36px',\n      top: '50%',\n      color: '',\n    }),\n    valueContainer: (provided) => ({\n      ...provided,\n      height: '100%',\n    }),\n  };\n\n  return (\n    <ReactSelect\n      styles={customSelectStyle}\n      options={props.options.map((option) => ({\n        value: option,\n        label: props.optionsMap[option],\n      }))}\n      value={\n        props.option && {\n          value: props.option,\n          label: props.optionsMap[props.option],\n        }\n      }\n      onChange={(data) => props.onChange(data.value)}\n      // onInputChange={(data) => props.onChange(data)}\n      placeholder={props.placeholder}\n      isSearchable={false}\n      tabSelectsValue={false}\n    />\n  );\n};\n\nexport default Select;\n","import GridConstants from './../services/GridConstants.js';\n\nconst generateMaze = async (maze, grid, setGrid, resetGrid, speed) => {\n  if (!maze) {\n    return Promise.resolve({ finished: false, grid: grid });\n  }\n  grid = new Array(GridConstants.SIZE).fill(GridConstants.DEFAULT_SQ);\n  setGrid(grid);\n\n  let delay = 10;\n  switch (maze) {\n    case 'random':\n      return await randomMaze(grid, setGrid, 0, delay);\n    case 'dfs':\n      return await dfs(grid, setGrid, 0, delay);\n    case 'recursiveDivision':\n      return await recursiveDivision(grid, setGrid, 0, delay);\n    case 'kruskal':\n      return await kruskal(grid, setGrid, 0, delay);\n    case 'prim':\n      return await prim(grid, setGrid, 0, delay);\n    default:\n  }\n};\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst drawRow = (grid, setGrid, tick, delay, row, colRange) => {\n  for (let i = colRange[0]; i <= colRange[1]; i++, tick += delay) {\n    const sq = row * GridConstants.WIDTH + i;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawCol = (grid, setGrid, tick, delay, col, rowRange) => {\n  for (let i = rowRange[0]; i <= rowRange[1]; i++, tick += delay) {\n    const sq = i * GridConstants.WIDTH + col;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawMazeBorder = (grid, setGrid, tick, delay) => {\n  for (let i = 0; i < GridConstants.WIDTH; i++, tick += delay) {\n    const topRow = GridConstants.getSq(0, i);\n    const bottomRow = GridConstants.getSq(GridConstants.HEIGHT - 1, i);\n    grid = changeSquare(grid, setGrid, topRow, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, bottomRow, GridConstants.WALL_SQ, tick);\n  }\n  for (let i = 0; i < GridConstants.HEIGHT; i++, tick += delay) {\n    const leftCol = GridConstants.getSq(i, 0);\n    const rightCol = GridConstants.getSq(i, GridConstants.WIDTH - 1);\n    grid = changeSquare(grid, setGrid, leftCol, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, rightCol, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst generateWallGrid = (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let row = 1; row < GridConstants.HEIGHT - 1; row++) {\n    for (let col = 1; col < GridConstants.WIDTH - 1; col++) {\n      if (!(row % 2 && col % 2)) {\n        grid[GridConstants.getSq(row, col)] = GridConstants.WALL_SQ;\n      }\n    }\n  }\n  setTimeout(() => {\n    setGrid(grid);\n  }, tick);\n  return [tick, [...grid]];\n};\n\nconst getRandomNumberBetween = (start, end) => {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n};\n\nconst getRandomElement = (array) => {\n  return array.splice(getRandomNumberBetween(0, array.length - 1), 1)[0];\n};\n\nconst shuffleArray = (array) => {\n  const newArray = [];\n  while (array.length > 0) {\n    newArray.push(getRandomElement(array));\n  }\n  return newArray;\n};\n\nconst getClosestEmptyTileFrom = (grid, from) => {\n  return grid.reduce((closest, sq, idx) => {\n    if (sq === GridConstants.DEFAULT_SQ) {\n      if (closest === -1) {\n        return idx;\n      } else {\n        const closestDist = GridConstants.dist(from, closest);\n        const sqDist = GridConstants.dist(from, idx);\n        return sqDist < closestDist ? idx : closest;\n      }\n    } else {\n      return closest;\n    }\n  }, -1);\n};\n\nconst generateStartEndPosition = (\n  grid,\n  setGrid,\n  idealStart,\n  idealEnd,\n  delay\n) => {\n  const start = getClosestEmptyTileFrom(grid, idealStart);\n  const end = getClosestEmptyTileFrom(grid, idealEnd);\n  grid = changeSquare(grid, setGrid, start, GridConstants.START_SQ, delay);\n  return changeSquare(grid, setGrid, end, GridConstants.END_SQ, delay);\n};\n\nconst randomMaze = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let i = 0; i < grid.length; i++) {\n    if (GridConstants.validMazeMove(i, i) && Math.random() < 0.35) {\n      grid[i] = GridConstants.WALL_SQ;\n    }\n  }\n  setTimeout(() => setGrid(grid), tick);\n\n  grid = [...grid];\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(0, 0),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst dfs = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  const start = GridConstants.getSq(1, 1);\n  const visited = new Set([start]);\n  const path = [start];\n  while (path.length > 0) {\n    const currSquare = path.pop();\n    let moves = [-2, 2, -2 * GridConstants.WIDTH, 2 * GridConstants.WIDTH];\n    moves = moves.filter((move) =>\n      GridConstants.validMazeMove(currSquare, currSquare + move)\n    );\n\n    while (moves.length > 0) {\n      const nextMove =\n        currSquare + moves.splice(Math.random() * moves.length, 1)[0];\n      const nextMoves = [(currSquare + nextMove) / 2, nextMove];\n      if (!visited.has(nextMove)) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[0],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[1],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        visited.add(nextMove);\n        path.push(nextMove);\n        path.push(nextMove);\n        break;\n      }\n    }\n  }\n\n  // place end as far away as possible from start\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst recursiveDivision = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n\n  [tick, grid] = divide(\n    grid,\n    setGrid,\n    tick,\n    delay,\n    [0, GridConstants.HEIGHT - 1],\n    [0, GridConstants.WIDTH - 1]\n  );\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst divide = (grid, setGrid, tick, delay, rowRange, colRange) => {\n  const [possibleRows, possibleRowHoles] = [[], []];\n  const [possibleCols, possibleColHoles] = [[], []];\n  for (let i = rowRange[0] + 1; i < rowRange[1]; i++) {\n    if ((i - rowRange[0]) % 2 === 0) {\n      possibleRows.push(i);\n    } else {\n      possibleRowHoles.push(i);\n    }\n  }\n  for (let i = colRange[0] + 1; i < colRange[1]; i++) {\n    if ((i - colRange[0]) % 2 === 0) {\n      possibleCols.push(i);\n    } else {\n      possibleColHoles.push(i);\n    }\n  }\n\n  if (possibleRows.length === 0 || possibleCols.length === 0) {\n    return [tick, grid];\n  } else {\n    if (possibleRows.length >= possibleCols.length) {\n      const randomRow = getRandomElement(possibleRows);\n      [tick, grid] = drawRow(grid, setGrid, tick, delay, randomRow, colRange);\n      const randomColHole = getRandomElement(possibleColHoles);\n      const randomHole = randomRow * GridConstants.WIDTH + randomColHole;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [rowRange[0], randomRow],\n        colRange\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [randomRow, rowRange[1]],\n        colRange\n      );\n    } else {\n      let randomCol = getRandomElement(possibleCols);\n      [tick, grid] = drawCol(grid, setGrid, tick, delay, randomCol, rowRange);\n      const randomRowHole = getRandomElement(possibleRowHoles);\n      const randomHole = randomRowHole * GridConstants.WIDTH + randomCol;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        colRange[0],\n        randomCol,\n      ]);\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        randomCol,\n        colRange[1],\n      ]);\n    }\n    return [tick, grid];\n  }\n};\n\nconst kruskal = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let treeSet = {};\n  let wallMap = {};\n\n  // fill wallMap and treeSet\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    const [iRow, iCol] = GridConstants.getCoor(i);\n    if (GridConstants.validMazeMove(i, i)) {\n      if (iRow % 2 && iCol % 2) {\n        treeSet[i] = new Set([i]);\n      } else {\n        if (iCol % 2) {\n          wallMap[i] = [i - GridConstants.WIDTH, i + GridConstants.WIDTH];\n        } else if (iRow % 2) {\n          wallMap[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  for (const [wall, [sq1, sq2]] of shuffleArray(Object.entries(wallMap))) {\n    if (!treeSet[sq1].has(sq2)) {\n      grid = changeSquare(\n        grid,\n        setGrid,\n        wall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      const union = new Set([...treeSet[sq1], ...treeSet[sq2]]);\n      treeSet[sq1].forEach((sq) => (treeSet[sq] = union));\n      treeSet[sq2].forEach((sq) => (treeSet[sq] = union));\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst prim = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let neighborSquares = {};\n  let neighborWalls = {};\n\n  // fill walls\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    if (GridConstants.validMazeMove(i, i)) {\n      const [iRow, iCol] = GridConstants.getCoor(i);\n      if (iRow % 2 && iCol % 2) {\n        const t = GridConstants.validMazeMove(i, i - GridConstants.WIDTH)\n          ? [i - GridConstants.WIDTH]\n          : [];\n        const r = GridConstants.validMazeMove(i, i + 1) ? [i + 1] : [];\n        const b = GridConstants.validMazeMove(i, i + GridConstants.WIDTH)\n          ? [i + GridConstants.WIDTH]\n          : [];\n        const l = GridConstants.validMazeMove(i, i - 1) ? [i - 1] : [];\n        neighborWalls[i] = [...t, ...r, ...b, ...l];\n      } else if (iRow % 2 ^ iCol % 2) {\n        if (iCol % 2) {\n          neighborSquares[i] = [\n            i - GridConstants.WIDTH,\n            i + GridConstants.WIDTH,\n          ];\n        } else if (iRow % 2) {\n          neighborSquares[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  const visitedSquares = new Set([GridConstants.getSq(1, 1)]);\n  let visitedWalls = [...neighborWalls[GridConstants.getSq(1, 1)]];\n  while (visitedWalls.length > 0) {\n    const randomWall = getRandomElement(visitedWalls);\n    const [sq1, sq2] = neighborSquares[randomWall];\n    if (sq1 > GridConstants.SIZE || sq2 > GridConstants.SIZE) {\n    }\n    if (visitedSquares.has(sq1) ^ visitedSquares.has(sq2)) {\n      if (!visitedSquares.has(sq1)) {\n        visitedSquares.add(sq1);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq1]];\n      } else {\n        visitedSquares.add(sq2);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq2]];\n      }\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomWall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nexport default { generateMaze };\n","import React from 'react';\nimport Select from './Select';\nimport Animations from './../services/Animations.js';\nimport Maze from './../services/Maze.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/TopBar.css';\n\nconst TopBar = ({\n  grid,\n  setGrid,\n  resetGrid,\n  setStartIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  setIsAnimating,\n  setIsAnimatingFinished,\n  algorithm,\n  setAlgorithm,\n  maze,\n  setMaze,\n  speed,\n  setSpeed,\n}) => {\n  const handleAlgorithmSubmit = async (event) => {\n    event.preventDefault();\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Animations.animate(algorithm, grid, setGrid, speed);\n      setIsAnimating(promise.isAnimating);\n      setIsAnimatingFinished(promise.isAnimatingFinished);\n    }\n  };\n\n  const handleMazeSubmit = async (maze) => {\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Maze.generateMaze(maze, grid, setGrid, resetGrid);\n      setMaze(null);\n      setStartIsCovering(GridConstants.DEFAULT_SQ);\n      setEndIsCovering(GridConstants.DEFAULT_SQ);\n      setIsAnimating(promise.finished);\n      setIsAnimatingFinished(false);\n    }\n  };\n\n  const onAlgorithmChange = (alg) => {\n    setAlgorithm(alg);\n  };\n\n  const onMazeChange = (maze) => {\n    setMaze(maze);\n    handleMazeSubmit(maze);\n  };\n\n  const onSpeedChange = (speed) => {\n    setSpeed(speed);\n  };\n\n  const handleResetClick = (e) => {\n    if (!isAnimating) {\n      e.preventDefault();\n      resetGrid();\n    }\n  };\n\n  const algorithmsMap = {\n    dijkstra: 'Dijkstra',\n    astar: 'A* Search',\n    greedy: 'Greedy BFS',\n    dfs: 'DFS',\n    bfs: 'BFS',\n  };\n  const algorithmsPlaceholder = 'Algorithm';\n\n  const mazesMap = {\n    random: 'Random',\n    dfs: 'DFS',\n    recursiveDivision: 'Recursive Division',\n    kruskal: 'Kruskal',\n    prim: 'Prim',\n  };\n  const mazePlaceholder = 'Maze';\n\n  const speedMap = {\n    slow: 'Slow',\n    medium: 'Medium',\n    fast: 'Fast',\n  };\n  const speedPlaceholder = 'Speed';\n\n  return (\n    <div className='topBar'>\n      <h1 className='title'>Path Visualizer</h1>\n      <div className='optionsContainer'>\n        <div className='topBarItemContainer'>\n          <Select\n            option={algorithm}\n            onChange={onAlgorithmChange}\n            options={Object.keys(algorithmsMap)}\n            optionsMap={algorithmsMap}\n            placeholder={algorithmsPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={speed}\n            onChange={onSpeedChange}\n            options={Object.keys(speedMap)}\n            optionsMap={speedMap}\n            placeholder={speedPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={maze}\n            onChange={onMazeChange}\n            options={Object.keys(mazesMap)}\n            optionsMap={mazesMap}\n            placeholder={mazePlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <button\n            className={\n              isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton'\n            }\n            onClick={handleAlgorithmSubmit}>\n            Visualize\n          </button>\n          <button\n            className={\n              (isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton') +\n              ' resetButton'\n            }\n            onClick={handleResetClick}>\n            Reset\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TopBar;\n","import React from 'react';\nimport './../styles/Legend.css';\n\nconst Legend = ({ name, img }) => {\n  return (\n    <span className='legendContainer'>\n      <span className={`legend ${name}Legend`}>\n        {img && (\n          <img className='legendImg' src={img} alt={img} draggable='false' />\n        )}\n      </span>\n      <span className='legendText'>{name}</span>\n    </span>\n  );\n};\n\nexport default Legend;\n","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport Grid from './Grid.js';\nimport TopBar from './TopBar.js';\nimport Legend from './Legend.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/App.css';\n\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\n\nfunction App() {\n  const [grid, setGrid] = useState(GridConstants.INITIAL_GRID);\n  const [startIsCovering, setStartIsCovering] = useState(\n    GridConstants.DEFAULT_SQ\n  );\n  const [endIsCovering, setEndIsCovering] = useState(GridConstants.DEFAULT_SQ);\n  const [algorithm, setAlgorithm] = useState(null);\n  const [speed, setSpeed] = useState('fast');\n  const [maze, setMaze] = useState(null);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isAnimatingFinished, setIsAnimatingFinished] = useState(false);\n  const isAnimatingRef = useRef(isAnimating);\n  const resetGrid = useCallback(() => {\n    const updateDimensions = () => {\n      if (!isAnimatingRef.current) {\n        const topBarHeight = document.getElementsByClassName('topBar')[0]\n          .offsetHeight;\n        const legendsHeight = document.getElementsByClassName(\n          'legendsContainer'\n        )[0].offsetHeight;\n        const gridVerticalMargin = 20;\n        const gridHorizontalMargin = 30;\n        let width = Math.floor((window.innerWidth - gridHorizontalMargin) / 25);\n        let height = Math.floor(\n          (window.innerHeight -\n            topBarHeight -\n            legendsHeight -\n            gridVerticalMargin) /\n            25\n        );\n        GridConstants.update(width, height);\n      }\n    };\n    updateDimensions();\n    setGrid(GridConstants.INITIAL_GRID);\n    setIsAnimatingFinished(false);\n    setStartIsCovering(GridConstants.DEFAULT_SQ);\n    setEndIsCovering(GridConstants.DEFAULT_SQ);\n    setAlgorithm(null);\n    setMaze(null);\n    setSpeed('fast');\n  }, []);\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      const topBarHeight = document.getElementsByClassName('topBar')[0]\n        .offsetHeight;\n      const legendsHeight = document.getElementsByClassName(\n        'legendsContainer'\n      )[0].offsetHeight;\n      const gridVerticalMargin = 20;\n      const gridHorizontalMargin = 30;\n      let width = Math.floor((window.innerWidth - gridHorizontalMargin) / 25);\n      let height = Math.floor(\n        (window.innerHeight -\n          topBarHeight -\n          legendsHeight -\n          gridVerticalMargin) /\n          25\n      );\n      GridConstants.update(width, height);\n      resetGrid();\n    };\n    updateDimensions();\n  }, [resetGrid]);\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (!isAnimating) {\n        const topBarHeight = document.getElementsByClassName('topBar')[0]\n          .offsetHeight;\n        const legendsHeight = document.getElementsByClassName(\n          'legendsContainer'\n        )[0].offsetHeight;\n        const gridVerticalMargin = 20;\n        const gridHorizontalMargin = 30;\n        let width = Math.floor((window.innerWidth - gridHorizontalMargin) / 25);\n        let height = Math.floor(\n          (window.innerHeight -\n            topBarHeight -\n            legendsHeight -\n            gridVerticalMargin) /\n            25\n        );\n        GridConstants.update(width, height);\n        resetGrid();\n      }\n    };\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, [isAnimating, resetGrid]);\n\n  const legends = [\n    {\n      name: 'Start',\n      img: start,\n    },\n    {\n      name: 'End',\n      img: end,\n    },\n    {\n      name: 'Weight',\n      img: weight,\n    },\n    {\n      name: 'Wall',\n    },\n    {\n      name: 'Visited',\n    },\n    {\n      name: 'Path',\n    },\n  ];\n\n  const gridStyle = {\n    gridTemplateColumns: `repeat(${GridConstants.WIDTH}, 25px)`,\n    gridTemplateRows: `repeat(${GridConstants.HEIGHT}, 25px)`,\n  };\n\n  return (\n    <div className='page'>\n      <TopBar\n        grid={grid}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        setStartIsCovering={setStartIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        setIsAnimating={setIsAnimating}\n        setIsAnimatingFinished={setIsAnimatingFinished}\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        speed={speed}\n        setSpeed={setSpeed}\n        maze={maze}\n        setMaze={setMaze}\n      />\n      <div className='legendsContainer'>\n        {legends.map((legend) => (\n          <Legend key={legend.name} name={legend.name} img={legend.img} />\n        ))}\n      </div>\n      <Grid\n        grid={grid}\n        gridStyle={gridStyle}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        startIsCovering={startIsCovering}\n        setStartIsCovering={setStartIsCovering}\n        endIsCovering={endIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        isAnimatingFinished={isAnimatingFinished}\n        algorithm={algorithm}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App className='page' />, document.getElementById('root'));\n"],"sourceRoot":""}