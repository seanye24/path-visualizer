{"version":3,"sources":["images/weight.svg","images/start.svg","images/end.svg","services/GridConstants.js","components/Square.js","services/Algorithms.js","services/Animations.js","components/Grid.js","components/Select.js","services/Maze.js","components/TopBar.js","components/Legend.js","components/App.js","index.js"],"names":["module","exports","WIDTH","HEIGHT","SIZE","INITIAL_START","INITIAL_END","INITIAL_GRID","getRow","getCol","getCoor","getSq","dist","validMove","validMazeMove","GridConstants","DEFAULT_SQ","START_SQ","END_SQ","WALL_SQ","WEIGHT_SQ","VISITED_SQ","VISITED_WEIGHT_SQ","VISITED_HEAD_SQ","VISITED_FINISHED_SQ","VISITED_FINISHED_WEIGHT_SQ","PATH_SQ","PATH_WEIGHT_SQ","PATH_HEAD_SQ","PATH_FINISHED_SQ","PATH_FINISHED_WEIGHT_SQ","update","width","height","Math","floor","Array","fill","sq","row","col","start","end","abs","endRow","endCol","window","innerWidth","innerHeight","React","memo","props","id","className","onMouseEnter","onMouseDown","onMouseUp","onKeyDown","onKeyUp","tabIndex","src","weight","draggable","alt","grid","findIndex","prev","visited","weights","Number","MAX_SAFE_INTEGER","pq","currSquare","shift","push","moves","map","move","filter","nextSquare","moveWeight","includes","splice","indexOf","inserted","i","length","path","unshift","heuristic","count","stack","pop","queue","clearAnimate","setGrid","nextGrid","animate","algorithm","speed","a","Promise","resolve","isAnimating","isAnimatingFinished","pathDelay","visitedDelay","Algorithms","square","tick","prevSquare","changeSquare","ind","squareType","wait","ms","setTimeout","delay","Grid","gridStyle","startIsCovering","setStartIsCovering","endIsCovering","setEndIsCovering","useState","isMouseDown","setIsMouseDown","isHoldingStart","setIsHoldingStart","isHoldingEnd","setIsHoldingEnd","isWDown","setIsWDown","startSq","s","endSq","Animations","updateGridOnMouseEnter","updateGridOnMouseDown","e","key","renderSquare","sqType","style","Select","customSelectStyle","menu","provided","state","backgroundColor","border","margin","padding","menuList","borderRadius","container","display","alignItems","control","menuIsOpen","boxShadow","fontFamily","fontWeight","fontSize","cursor","userSelect","color","hasValue","dropdownIndicator","indicatorSeparator","placeholder","option","singleValue","whiteSpace","overflow","textOverflow","paddingRight","maxWidth","lineHeight","top","valueContainer","styles","options","value","label","optionsMap","onChange","data","isSearchable","tabSelectsValue","generateMaze","maze","resetGrid","finished","randomMaze","dfs","recursiveDivision","kruskal","prim","drawMazeBorder","topRow","bottomRow","leftCol","rightCol","generateWallGrid","getRandomElement","array","random","shuffleArray","newArray","getClosestEmptyTileFrom","from","reduce","closest","idx","closestDist","generateStartEndPosition","idealStart","idealEnd","Set","nextMove","nextMoves","has","add","divide","rowRange","colRange","possibleRows","possibleRowHoles","possibleCols","possibleColHoles","randomRow","drawRow","randomColHole","randomHole","randomCol","drawCol","treeSet","wallMap","iRow","iCol","Object","entries","wall","sq1","sq2","union","forEach","neighborSquares","neighborWalls","t","r","b","l","visitedSquares","visitedWalls","randomWall","TopBar","setIsAnimating","setIsAnimatingFinished","setAlgorithm","setMaze","setSpeed","handleAlgorithmSubmit","event","preventDefault","promise","handleMazeSubmit","Maze","algorithmsMap","dijkstra","astar","greedy","bfs","mazesMap","speedMap","slow","medium","fast","alg","keys","onClick","Legend","name","img","App","useEffect","topBarHeight","document","getElementsByClassName","offsetHeight","legendsHeight","updateDimensions","addEventListener","removeEventListener","legends","gridTemplateColumns","gridTemplateRows","legend","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.7a495898.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.f8a5f7dd.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.ff2b9671.svg\";","module.exports = __webpack_public_path__ + \"static/media/end.93326d55.svg\";","let GridConstants = {};\nlet WIDTH,\n  HEIGHT,\n  SIZE,\n  INITIAL_START,\n  INITIAL_END,\n  INITIAL_GRID,\n  getRow,\n  getCol,\n  getCoor,\n  getSq,\n  dist,\n  validMove,\n  validMazeMove;\n\nGridConstants.DEFAULT_SQ = 'square';\nGridConstants.START_SQ = 'startSquare';\nGridConstants.END_SQ = 'endSquare';\nGridConstants.WALL_SQ = 'wallSquare';\nGridConstants.WEIGHT_SQ = 'weightSquare';\nGridConstants.VISITED_SQ = 'visitedSquare';\nGridConstants.VISITED_WEIGHT_SQ = 'visitedWeightSquare';\nGridConstants.VISITED_HEAD_SQ = 'visitedHeadSquare';\nGridConstants.VISITED_FINISHED_SQ = 'visitedFinishedSquare';\nGridConstants.VISITED_FINISHED_WEIGHT_SQ = 'visitedFinishedWeightSquare';\nGridConstants.PATH_SQ = 'pathSquare';\nGridConstants.PATH_WEIGHT_SQ = 'pathWeightSquare';\nGridConstants.PATH_HEAD_SQ = 'pathHeadSquare';\nGridConstants.PATH_FINISHED_SQ = 'pathFinishedSquare';\nGridConstants.PATH_FINISHED_WEIGHT_SQ = 'pathFinishedWeightSquare';\n\nconst update = (width, height) => {\n  WIDTH = width;\n  HEIGHT = height;\n\n  // maintain odd number of rows and cols for maze\n  if (WIDTH % 2 === 0) {\n    WIDTH--;\n  }\n  if (HEIGHT % 2 === 0) {\n    HEIGHT--;\n  }\n  SIZE = WIDTH * HEIGHT;\n  INITIAL_START = (Math.floor(HEIGHT / 2) - 1) * WIDTH + Math.floor(WIDTH / 6);\n  INITIAL_END =\n    (Math.floor(HEIGHT / 2) - 1) * WIDTH + Math.floor((WIDTH * 5) / 6);\n  INITIAL_GRID = new Array(SIZE).fill(GridConstants.DEFAULT_SQ);\n  INITIAL_GRID[INITIAL_START] = GridConstants.START_SQ;\n  INITIAL_GRID[INITIAL_END] = GridConstants.END_SQ;\n\n  getRow = (sq) => Math.floor(sq / WIDTH);\n\n  getCol = (sq) => sq % WIDTH;\n\n  getCoor = (sq) => [getRow(sq), getCol(sq)];\n\n  getSq = (row, col) => row * WIDTH + col;\n\n  dist = (start, end) =>\n    Math.abs(getRow(start) - getRow(end)) +\n    Math.abs(getCol(start) - getCol(end));\n\n  validMove = (start, end) =>\n    end < SIZE && end >= 0 && Math.abs(getCol(end) - getCol(start)) <= 2;\n\n  validMazeMove = (start, end) => {\n    const [endRow, endCol] = getCoor(end);\n    return (\n      endRow >= 1 &&\n      endRow < HEIGHT - 1 &&\n      endCol >= 1 &&\n      endCol < WIDTH - 1 &&\n      validMove(start, end)\n    );\n  };\n\n  GridConstants.WIDTH = WIDTH;\n  GridConstants.HEIGHT = HEIGHT;\n  GridConstants.SIZE = SIZE;\n  GridConstants.INITIAL_START = INITIAL_START;\n  GridConstants.INITIAL_END = INITIAL_END;\n  GridConstants.INITIAL_GRID = INITIAL_GRID;\n  GridConstants.getRow = getRow;\n  GridConstants.getCol = getCol;\n  GridConstants.getCoor = getCoor;\n  GridConstants.getSq = getSq;\n  GridConstants.dist = dist;\n  GridConstants.validMove = validMove;\n  GridConstants.validMazeMove = validMazeMove;\n  GridConstants.update = update;\n};\n\nupdate(\n  Math.floor((window.innerWidth - 25) / 25),\n  Math.floor((window.innerHeight - 150) / 25)\n);\n\nexport default GridConstants;\n","import React from 'react';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/Square.css';\n\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\n\nconst Square = (props) => {\n  return (\n    <div\n      id={props.id}\n      className={props.className}\n      onMouseEnter={props.onMouseEnter}\n      onMouseDown={props.onMouseDown}\n      onMouseUp={props.onMouseUp}\n      onKeyDown={props.onKeyDown}\n      onKeyUp={props.onKeyUp}\n      tabIndex={-1}>\n      {(props.className === GridConstants.WEIGHT_SQ ||\n        props.className === GridConstants.VISITED_WEIGHT_SQ ||\n        props.className === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n        props.className === GridConstants.PATH_WEIGHT_SQ ||\n        props.className === GridConstants.PATH_FINISHED_WEIGHT_SQ) && (\n        <img\n          src={weight}\n          className='weightImg'\n          draggable='false'\n          alt='weight'\n        />\n      )}\n      {(props.className === GridConstants.START_SQ ||\n        props.className === GridConstants.PATH_HEAD_SQ) && (\n        <img src={start} className='startImg' draggable='false' alt='start' />\n      )}\n      {props.className === GridConstants.END_SQ && (\n        <img src={end} className='endImg' draggable='false' alt='end' />\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(Square);\n","import GridConstants from './../services/GridConstants.js';\n\nconst dijkstra = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (moveWeight < weights[pq[i]]) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst astar = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(GridConstants.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const heuristic = (start, end) => {\n    return (\n      Math.abs(\n        Math.floor(start / GridConstants.WIDTH) -\n          Math.floor(end / GridConstants.WIDTH)\n      ) + Math.abs((start % GridConstants.WIDTH) - (end % GridConstants.WIDTH))\n    );\n  };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (\n              moveWeight + heuristic(nextSquare, end) <\n              weights[pq[i]] + heuristic(pq[i], end)\n            ) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  let path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n\n  return [visited, path];\n};\n\nconst greedy = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = { start: 1 };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains and decentivize weights\n      let moveWeight = GridConstants.dist(nextSquare, end);\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === GridConstants.WEIGHT_SQ) {\n        moveWeight += 10;\n      }\n\n      // insert into priority queue\n      if (!pq.includes(nextSquare) && !visited.includes(nextSquare)) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n        let inserted = false;\n        for (let i = 0; i < pq.length; i++) {\n          if (moveWeight < weights[pq[i]]) {\n            pq.splice(i, 0, nextSquare);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          pq.push(nextSquare);\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst dfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const stack = [start];\n  while (stack.length > 0) {\n    const currSquare = stack.pop();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into stack\n      if (!visited.includes(nextSquare) && !stack.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        stack.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst bfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const queue = [start];\n  while (queue.length > 0) {\n    const currSquare = queue.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -GridConstants.WIDTH, GridConstants.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) =>\n        GridConstants.validMove(currSquare, nextSquare)\n      )) {\n      // ignore mountains\n      if (grid[nextSquare] === GridConstants.WALL_SQ) {\n        continue;\n      }\n\n      // insert into queue\n      if (!visited.includes(nextSquare) && !queue.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        queue.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > GridConstants.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nexport default { dijkstra, astar, greedy, dfs, bfs };\n","import GridConstants from './../services/GridConstants.js';\nimport Algorithms from './Algorithms';\n\nconst clearAnimate = (grid, setGrid) => {\n  const nextGrid = grid.map((sq) => {\n    if (sq === GridConstants.START_SQ || sq === GridConstants.END_SQ || sq === GridConstants.WALL_SQ) {\n      return sq;\n    } else if (\n      sq === GridConstants.WEIGHT_SQ ||\n      sq === GridConstants.VISITED_WEIGHT_SQ ||\n      sq === GridConstants.VISITED_FINISHED_WEIGHT_SQ ||\n      sq === GridConstants.PATH_WEIGHT_SQ ||\n      sq === GridConstants.PATH_FINISHED_WEIGHT_SQ\n    ) {\n      return GridConstants.WEIGHT_SQ;\n    } else {\n      return GridConstants.DEFAULT_SQ;\n    }\n  });\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst animate = async (algorithm, grid, setGrid, speed) => {\n  if (!algorithm || !speed) {\n    return Promise.resolve({ isAnimating: false, isAnimatingFinished: false });\n  }\n\n  let pathDelay = 50;\n  let visitedDelay;\n  switch (speed) {\n    case 'none':\n      break;\n    case 'slow':\n      visitedDelay = 70;\n      break;\n    case 'medium':\n      visitedDelay = 40;\n      break;\n    case 'fast':\n      visitedDelay = 25;\n      break;\n    default:\n  }\n\n  grid = clearAnimate(grid, setGrid);\n  let visited, path;\n  switch (algorithm) {\n    case 'dijkstra':\n      [visited, path] = Algorithms.dijkstra(grid);\n      break;\n    case 'astar':\n      [visited, path] = Algorithms.astar(grid);\n      break;\n    case 'greedy':\n      [visited, path] = Algorithms.greedy(grid);\n      break;\n    case 'dfs':\n      [visited, path] = Algorithms.dfs(grid);\n      break;\n    case 'bfs':\n      [visited, path] = Algorithms.bfs(grid);\n      break;\n    default:\n  }\n\n  const start = grid.findIndex((sq) => sq === GridConstants.START_SQ);\n  const end = grid.findIndex((sq) => sq === GridConstants.END_SQ);\n  visited = visited.filter((square) => square !== start && square !== end);\n  path = path.filter((square) => square !== start && square !== end);\n\n  // animate visited\n  let tick = 0;\n  let prevSquare = null;\n  for (const square of visited) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += visitedDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_WEIGHT_SQ\n          : GridConstants.VISITED_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.VISITED_HEAD_SQ, tick);\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      const squareType =\n        grid[square] === GridConstants.WEIGHT_SQ\n          ? GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          : GridConstants.VISITED_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n  if (speed !== 'none' && prevSquare) {\n    grid = changeSquare(\n      grid,\n      setGrid,\n      prevSquare.ind,\n      prevSquare.squareType,\n      tick\n    );\n  }\n\n  // animate path\n  prevSquare = null;\n  for (const square of path) {\n    if (speed !== 'none') {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType,\n          (tick += pathDelay)\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_WEIGHT_SQ\n          ? GridConstants.PATH_WEIGHT_SQ\n          : GridConstants.PATH_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.PATH_HEAD_SQ, tick);\n      prevSquare = { ind: square, squareType: squareType };\n    } else {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === GridConstants.VISITED_FINISHED_WEIGHT_SQ\n          ? GridConstants.PATH_FINISHED_WEIGHT_SQ\n          : GridConstants.PATH_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, GridConstants.PATH_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n    }\n  }\n  await wait(tick);\n  return Promise.resolve({ isAnimating: false, isAnimatingFinished: true });\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nexport default { animate };\n","import React, { useState } from 'react';\nimport Square from './Square.js';\nimport Animations from './../services/Animations.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/Grid.css';\n\nconst Grid = ({\n  grid,\n  gridStyle,\n  setGrid,\n  startIsCovering,\n  setStartIsCovering,\n  endIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  isAnimatingFinished,\n  algorithm,\n}) => {\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isHoldingStart, setIsHoldingStart] = useState(false);\n  const [isHoldingEnd, setIsHoldingEnd] = useState(false);\n  const [isWDown, setIsWDown] = useState(false);\n\n  const updateGridOnMouseDown = (sq) => {\n    const nextGrid = [...grid];\n    if (grid[sq] === GridConstants.START_SQ) {\n      setIsHoldingStart(true);\n    } else if (grid[sq] === GridConstants.END_SQ) {\n      setIsHoldingEnd(true);\n    } else if (grid[sq] === GridConstants.WEIGHT_SQ) {\n      if (isWDown) {\n        nextGrid[sq] = GridConstants.DEFAULT_SQ;\n      } else {\n        nextGrid[sq] = GridConstants.WALL_SQ;\n      }\n    } else if (grid[sq] === GridConstants.WALL_SQ) {\n      if (isWDown) {\n        nextGrid[sq] = GridConstants.WEIGHT_SQ;\n      } else {\n        nextGrid[sq] = GridConstants.DEFAULT_SQ;\n      }\n    } else {\n      if (isWDown) {\n        nextGrid[sq] = GridConstants.WEIGHT_SQ;\n      } else {\n        nextGrid[sq] = GridConstants.WALL_SQ;\n      }\n    }\n    setGrid(nextGrid);\n  };\n\n  const updateGridOnMouseEnter = (sq) => {\n    const startSq = grid.findIndex((s) => s === GridConstants.START_SQ);\n    const endSq = grid.findIndex((s) => s === GridConstants.END_SQ);\n    if (isMouseDown && (sq !== startSq) & (sq !== endSq)) {\n      const nextGrid = [...grid];\n      if (isHoldingStart) {\n        nextGrid[startSq] = startIsCovering;\n        nextGrid[sq] = GridConstants.START_SQ;\n        setStartIsCovering(grid[sq]);\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none');\n          return;\n        }\n      } else if (isHoldingEnd) {\n        nextGrid[endSq] = endIsCovering;\n        nextGrid[sq] = GridConstants.END_SQ;\n        setEndIsCovering(grid[sq]);\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none');\n          return;\n        }\n      } else {\n        if (grid[sq] === GridConstants.WEIGHT_SQ) {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.DEFAULT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.WALL_SQ;\n          }\n        } else if (grid[sq] === GridConstants.WALL_SQ) {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.WEIGHT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.DEFAULT_SQ;\n          }\n        } else {\n          if (isWDown) {\n            nextGrid[sq] = GridConstants.WEIGHT_SQ;\n          } else {\n            nextGrid[sq] = GridConstants.WALL_SQ;\n          }\n        }\n      }\n      setGrid(nextGrid);\n    }\n  };\n\n  const onMouseEnter = (sq) => {\n    if (!isAnimating) {\n      updateGridOnMouseEnter(sq);\n    }\n  };\n\n  const onMouseDown = (sq) => {\n    if (!isAnimating) {\n      updateGridOnMouseDown(sq);\n      setIsMouseDown(true);\n    }\n  };\n\n  const onMouseUp = (sq) => {\n    if (!isAnimating) {\n      if (isHoldingStart) {\n        setIsHoldingStart(false);\n      } else if (isHoldingEnd) {\n        setIsHoldingEnd(false);\n      }\n      setIsMouseDown(false);\n    }\n  };\n\n  const onKeyDown = (e) => {\n    if (!isAnimating) {\n      if (e.key === 'w') {\n        setIsWDown(true);\n      }\n    }\n  };\n\n  const onKeyUp = (e) => {\n    if (!isAnimating) {\n      if (e.key === 'w') {\n        setIsWDown(false);\n      }\n    }\n  };\n\n  const renderSquare = (sqType, sq) => {\n    return (\n      <Square\n        key={sq}\n        id={sq}\n        className={sqType}\n        onMouseEnter={() => onMouseEnter(sq)}\n        onMouseDown={() => onMouseDown(sq)}\n        onMouseUp={() => onMouseUp(sq)}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n      />\n    );\n  };\n\n  const renderGrid = () => {\n    return grid.map((sqType, sq) => renderSquare(sqType, sq));\n  };\n\n  return (\n    <div style={gridStyle} className='grid'>\n      {renderGrid()}\n    </div>\n  );\n};\n\nexport default Grid;\n","import React from 'react';\nimport ReactSelect from 'react-select';\nimport './../styles/TopBar.css';\n\nconst Select = (props) => {\n  const customSelectStyle = {\n    menu: (provided, state) => ({\n      ...provided,\n      backgroundColor: 'rgb(17, 138, 178)',\n      width: '160px',\n      border: 'none',\n      margin: '0px',\n      padding: '0px',\n    }),\n    menuList: (provided, state) => ({\n      ...provided,\n      padding: '0px',\n      borderRadius: '0px 0px 5px 5px',\n    }),\n    container: (provided, state) => ({\n      ...provided,\n      height: '40px',\n      margin: 'auto 10px',\n      display: 'flex',\n      alignItems: 'center',\n    }),\n    control: (provided, state) => ({\n      ...provided,\n      width: '160px',\n      height: '100%',\n      border: 'none',\n      borderRadius: state.menuIsOpen ? '5px 5px 0px 0px' : '5px',\n      boxShadow: 'none',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n      fontSize: '20px',\n      cursor: 'pointer',\n      userSelect: 'none',\n\n      color: 'white',\n      backgroundColor:\n        state.hasValue || state.menuIsOpen\n          ? 'rgb(17, 138, 178)'\n          : 'transparent',\n      '&:hover': {\n        backgroundColor: 'rgb(17, 138, 178)',\n        color: 'white',\n        border: 'none',\n      },\n    }),\n    dropdownIndicator: (provided, state) => ({\n      margin: '3px',\n    }),\n    indicatorSeparator: (provided) => ({}),\n    placeholder: (provided, state) => ({}),\n    option: (provided, state) => ({\n      ...provided,\n      cursor: 'pointer',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n\n      color: 'white',\n      backgroundColor: 'rgb(17, 138, 178)',\n      '&:hover': {\n        color: 'rgb(38, 70, 83)',\n        backgroundColor: 'rgb(233, 196, 106)',\n      },\n    }),\n    singleValue: (provided) => ({\n      ...provided,\n      whiteSpace: 'nowrap',\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      paddingRight: '4px',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n      lineHeight: '36px',\n      top: '50%',\n      color: '',\n    }),\n    valueContainer: (provided) => ({\n      ...provided,\n      height: '100%',\n    }),\n  };\n\n  return (\n    <ReactSelect\n      styles={customSelectStyle}\n      options={props.options.map((option) => ({\n        value: option,\n        label: props.optionsMap[option],\n      }))}\n      value={\n        props.option && {\n          value: props.option,\n          label: props.optionsMap[props.option],\n        }\n      }\n      onChange={(data) => props.onChange(data.value)}\n      // onInputChange={(data) => props.onChange(data)}\n      placeholder={props.placeholder}\n      isSearchable={false}\n      tabSelectsValue={false}\n    />\n  );\n};\n\nexport default Select;\n","import GridConstants from './../services/GridConstants.js';\n\nconst generateMaze = async (maze, grid, setGrid, resetGrid, speed) => {\n  if (!maze) {\n    return Promise.resolve({ finished: false, grid: grid });\n  }\n  grid = new Array(GridConstants.SIZE).fill(GridConstants.DEFAULT_SQ);\n  setGrid(grid);\n\n  let delay = 10;\n  switch (maze) {\n    case 'random':\n      return await randomMaze(grid, setGrid, 0, delay);\n    case 'dfs':\n      return await dfs(grid, setGrid, 0, delay);\n    case 'recursiveDivision':\n      return await recursiveDivision(grid, setGrid, 0, delay);\n    case 'kruskal':\n      return await kruskal(grid, setGrid, 0, delay);\n    case 'prim':\n      return await prim(grid, setGrid, 0, delay);\n    default:\n  }\n};\n\nconst changeSquare = (grid, setGrid, square, squareType, delay) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  if (delay) {\n    setTimeout(() => {\n      setGrid(nextGrid);\n    }, delay);\n  } else {\n    setGrid(nextGrid);\n  }\n  return nextGrid;\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst drawRow = (grid, setGrid, tick, delay, row, colRange) => {\n  for (let i = colRange[0]; i <= colRange[1]; i++, tick += delay) {\n    const sq = row * GridConstants.WIDTH + i;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawCol = (grid, setGrid, tick, delay, col, rowRange) => {\n  for (let i = rowRange[0]; i <= rowRange[1]; i++, tick += delay) {\n    const sq = i * GridConstants.WIDTH + col;\n    grid = changeSquare(grid, setGrid, sq, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst drawMazeBorder = (grid, setGrid, tick, delay) => {\n  for (let i = 0; i < GridConstants.WIDTH; i++, tick += delay) {\n    const topRow = GridConstants.getSq(0, i);\n    const bottomRow = GridConstants.getSq(GridConstants.HEIGHT - 1, i);\n    grid = changeSquare(grid, setGrid, topRow, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, bottomRow, GridConstants.WALL_SQ, tick);\n  }\n  for (let i = 0; i < GridConstants.HEIGHT; i++, tick += delay) {\n    const leftCol = GridConstants.getSq(i, 0);\n    const rightCol = GridConstants.getSq(i, GridConstants.WIDTH - 1);\n    grid = changeSquare(grid, setGrid, leftCol, GridConstants.WALL_SQ, tick);\n    grid = changeSquare(grid, setGrid, rightCol, GridConstants.WALL_SQ, tick);\n  }\n  return [tick, grid];\n};\n\nconst generateWallGrid = (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let row = 1; row < GridConstants.HEIGHT - 1; row++) {\n    for (let col = 1; col < GridConstants.WIDTH - 1; col++) {\n      if (!(row % 2 && col % 2)) {\n        grid[GridConstants.getSq(row, col)] = GridConstants.WALL_SQ;\n      }\n    }\n  }\n  setTimeout(() => {\n    setGrid(grid);\n  }, tick);\n  return [tick, [...grid]];\n};\n\nconst getRandomNumberBetween = (start, end) => {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n};\n\nconst getRandomElement = (array) => {\n  return array.splice(getRandomNumberBetween(0, array.length - 1), 1)[0];\n};\n\nconst shuffleArray = (array) => {\n  const newArray = [];\n  while (array.length > 0) {\n    newArray.push(getRandomElement(array));\n  }\n  return newArray;\n};\n\nconst getClosestEmptyTileFrom = (grid, from) => {\n  return grid.reduce((closest, sq, idx) => {\n    if (sq === GridConstants.DEFAULT_SQ) {\n      if (closest === -1) {\n        return idx;\n      } else {\n        const closestDist = GridConstants.dist(from, closest);\n        const sqDist = GridConstants.dist(from, idx);\n        return sqDist < closestDist ? idx : closest;\n      }\n    } else {\n      return closest;\n    }\n  }, -1);\n};\n\nconst generateStartEndPosition = (\n  grid,\n  setGrid,\n  idealStart,\n  idealEnd,\n  delay\n) => {\n  const start = getClosestEmptyTileFrom(grid, idealStart);\n  const end = getClosestEmptyTileFrom(grid, idealEnd);\n  grid = changeSquare(grid, setGrid, start, GridConstants.START_SQ, delay);\n  return changeSquare(grid, setGrid, end, GridConstants.END_SQ, delay);\n};\n\nconst randomMaze = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n  for (let i = 0; i < grid.length; i++) {\n    if (GridConstants.validMazeMove(i, i) && Math.random() < 0.35) {\n      grid[i] = GridConstants.WALL_SQ;\n    }\n  }\n  setTimeout(() => setGrid(grid), tick);\n\n  grid = [...grid];\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(0, 0),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst dfs = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  const start = GridConstants.getSq(1, 1);\n  const visited = new Set([start]);\n  const path = [start];\n  while (path.length > 0) {\n    const currSquare = path.pop();\n    let moves = [-2, 2, -2 * GridConstants.WIDTH, 2 * GridConstants.WIDTH];\n    moves = moves.filter((move) =>\n      GridConstants.validMazeMove(currSquare, currSquare + move)\n    );\n\n    while (moves.length > 0) {\n      const nextMove =\n        currSquare + moves.splice(Math.random() * moves.length, 1)[0];\n      const nextMoves = [(currSquare + nextMove) / 2, nextMove];\n      if (!visited.has(nextMove)) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[0],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        grid = changeSquare(\n          grid,\n          setGrid,\n          nextMoves[1],\n          GridConstants.DEFAULT_SQ,\n          (tick += delay)\n        );\n        visited.add(nextMove);\n        path.push(nextMove);\n        path.push(nextMove);\n        break;\n      }\n    }\n  }\n\n  // place end as far away as possible from start\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.SIZE - 1, GridConstants.SIZE - 1),\n    (tick += delay)\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst recursiveDivision = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = drawMazeBorder(grid, setGrid, tick, delay);\n\n  [tick, grid] = divide(\n    grid,\n    setGrid,\n    tick,\n    delay,\n    [0, GridConstants.HEIGHT - 1],\n    [0, GridConstants.WIDTH - 1]\n  );\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst divide = (grid, setGrid, tick, delay, rowRange, colRange) => {\n  const [possibleRows, possibleRowHoles] = [[], []];\n  const [possibleCols, possibleColHoles] = [[], []];\n  for (let i = rowRange[0] + 1; i < rowRange[1]; i++) {\n    if ((i - rowRange[0]) % 2 === 0) {\n      possibleRows.push(i);\n    } else {\n      possibleRowHoles.push(i);\n    }\n  }\n  for (let i = colRange[0] + 1; i < colRange[1]; i++) {\n    if ((i - colRange[0]) % 2 === 0) {\n      possibleCols.push(i);\n    } else {\n      possibleColHoles.push(i);\n    }\n  }\n\n  if (possibleRows.length === 0 || possibleCols.length === 0) {\n    return [tick, grid];\n  } else {\n    if (possibleRows.length >= possibleCols.length) {\n      const randomRow = getRandomElement(possibleRows);\n      [tick, grid] = drawRow(grid, setGrid, tick, delay, randomRow, colRange);\n      const randomColHole = getRandomElement(possibleColHoles);\n      const randomHole = randomRow * GridConstants.WIDTH + randomColHole;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [rowRange[0], randomRow],\n        colRange\n      );\n      [tick, grid] = divide(\n        grid,\n        setGrid,\n        tick,\n        delay,\n        [randomRow, rowRange[1]],\n        colRange\n      );\n    } else {\n      let randomCol = getRandomElement(possibleCols);\n      [tick, grid] = drawCol(grid, setGrid, tick, delay, randomCol, rowRange);\n      const randomRowHole = getRandomElement(possibleRowHoles);\n      const randomHole = randomRowHole * GridConstants.WIDTH + randomCol;\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomHole,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        colRange[0],\n        randomCol,\n      ]);\n      [tick, grid] = divide(grid, setGrid, tick, delay, rowRange, [\n        randomCol,\n        colRange[1],\n      ]);\n    }\n    return [tick, grid];\n  }\n};\n\nconst kruskal = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let treeSet = {};\n  let wallMap = {};\n\n  // fill wallMap and treeSet\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    const [iRow, iCol] = GridConstants.getCoor(i);\n    if (GridConstants.validMazeMove(i, i)) {\n      if (iRow % 2 && iCol % 2) {\n        treeSet[i] = new Set([i]);\n      } else {\n        if (iCol % 2) {\n          wallMap[i] = [i - GridConstants.WIDTH, i + GridConstants.WIDTH];\n        } else if (iRow % 2) {\n          wallMap[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  for (const [wall, [sq1, sq2]] of shuffleArray(Object.entries(wallMap))) {\n    if (!treeSet[sq1].has(sq2)) {\n      grid = changeSquare(\n        grid,\n        setGrid,\n        wall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n      const union = new Set([...treeSet[sq1], ...treeSet[sq2]]);\n      treeSet[sq1].forEach((sq) => (treeSet[sq] = union));\n      treeSet[sq2].forEach((sq) => (treeSet[sq] = union));\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst prim = async (grid, setGrid, tick, delay) => {\n  [tick, grid] = generateWallGrid(grid, setGrid, tick, delay);\n  let neighborSquares = {};\n  let neighborWalls = {};\n\n  // fill walls\n  for (let i = 0; i < GridConstants.SIZE; i++) {\n    if (GridConstants.validMazeMove(i, i)) {\n      const [iRow, iCol] = GridConstants.getCoor(i);\n      if (iRow % 2 && iCol % 2) {\n        const t = GridConstants.validMazeMove(i, i - GridConstants.WIDTH)\n          ? [i - GridConstants.WIDTH]\n          : [];\n        const r = GridConstants.validMazeMove(i, i + 1) ? [i + 1] : [];\n        const b = GridConstants.validMazeMove(i, i + GridConstants.WIDTH)\n          ? [i + GridConstants.WIDTH]\n          : [];\n        const l = GridConstants.validMazeMove(i, i - 1) ? [i - 1] : [];\n        neighborWalls[i] = [...t, ...r, ...b, ...l];\n      } else if (iRow % 2 ^ iCol % 2) {\n        if (iCol % 2) {\n          neighborSquares[i] = [\n            i - GridConstants.WIDTH,\n            i + GridConstants.WIDTH,\n          ];\n        } else if (iRow % 2) {\n          neighborSquares[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  const visitedSquares = new Set([GridConstants.getSq(1, 1)]);\n  let visitedWalls = [...neighborWalls[GridConstants.getSq(1, 1)]];\n  while (visitedWalls.length > 0) {\n    const randomWall = getRandomElement(visitedWalls);\n    const [sq1, sq2] = neighborSquares[randomWall];\n    if (sq1 > GridConstants.SIZE || sq2 > GridConstants.SIZE) {\n    }\n    if (visitedSquares.has(sq1) ^ visitedSquares.has(sq2)) {\n      if (!visitedSquares.has(sq1)) {\n        visitedSquares.add(sq1);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq1]];\n      } else {\n        visitedSquares.add(sq2);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq2]];\n      }\n      grid = changeSquare(\n        grid,\n        setGrid,\n        randomWall,\n        GridConstants.DEFAULT_SQ,\n        (tick += delay)\n      );\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    GridConstants.getSq(1, 1),\n    GridConstants.getSq(GridConstants.HEIGHT - 1, GridConstants.WIDTH - 1),\n    tick\n  );\n  await wait(tick);\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nexport default { generateMaze };\n","import React from 'react';\nimport Select from './Select';\nimport Animations from './../services/Animations.js';\nimport Maze from './../services/Maze.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/TopBar.css';\n\nconst TopBar = ({\n  grid,\n  setGrid,\n  resetGrid,\n  setStartIsCovering,\n  setEndIsCovering,\n  isAnimating,\n  setIsAnimating,\n  setIsAnimatingFinished,\n  algorithm,\n  setAlgorithm,\n  maze,\n  setMaze,\n  speed,\n  setSpeed,\n}) => {\n  const handleAlgorithmSubmit = async (event) => {\n    event.preventDefault();\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Animations.animate(algorithm, grid, setGrid, speed);\n      setIsAnimating(promise.isAnimating);\n      setIsAnimatingFinished(promise.isAnimatingFinished);\n    }\n  };\n\n  const handleMazeSubmit = async (maze) => {\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const promise = await Maze.generateMaze(maze, grid, setGrid, resetGrid);\n      setMaze(null);\n      setStartIsCovering(GridConstants.DEFAULT_SQ);\n      setEndIsCovering(GridConstants.DEFAULT_SQ);\n      setIsAnimating(promise.finished);\n      setIsAnimatingFinished(false);\n    }\n  };\n\n  const onAlgorithmChange = (alg) => {\n    setAlgorithm(alg);\n  };\n\n  const onMazeChange = (maze) => {\n    setMaze(maze);\n    handleMazeSubmit(maze);\n  };\n\n  const onSpeedChange = (speed) => {\n    setSpeed(speed);\n  };\n\n  const handleResetClick = (e) => {\n    if (!isAnimating) {\n      e.preventDefault();\n      resetGrid();\n    }\n  };\n\n  const algorithmsMap = {\n    dijkstra: 'Dijkstra',\n    astar: 'A* Search',\n    greedy: 'Greedy BFS',\n    dfs: 'DFS',\n    bfs: 'BFS',\n  };\n  const algorithmsPlaceholder = 'Algorithm';\n\n  const mazesMap = {\n    random: 'Random',\n    dfs: 'DFS',\n    recursiveDivision: 'Recursive Division',\n    kruskal: 'Kruskal',\n    prim: 'Prim',\n  };\n  const mazePlaceholder = 'Maze';\n\n  const speedMap = {\n    slow: 'Slow',\n    medium: 'Medium',\n    fast: 'Fast',\n  };\n  const speedPlaceholder = 'Speed';\n\n  return (\n    <div className='topBar'>\n      <h1 className='title'>Path Visualizer</h1>\n      <div className='optionsContainer'>\n        <div className='topBarItemContainer'>\n          <Select\n            option={algorithm}\n            onChange={onAlgorithmChange}\n            options={Object.keys(algorithmsMap)}\n            optionsMap={algorithmsMap}\n            placeholder={algorithmsPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={speed}\n            onChange={onSpeedChange}\n            options={Object.keys(speedMap)}\n            optionsMap={speedMap}\n            placeholder={speedPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={maze}\n            onChange={onMazeChange}\n            options={Object.keys(mazesMap)}\n            optionsMap={mazesMap}\n            placeholder={mazePlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <button\n            className={\n              isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton'\n            }\n            onClick={handleAlgorithmSubmit}>\n            Visualize\n          </button>\n          <button\n            className={\n              (isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton') +\n              ' resetButton'\n            }\n            onClick={handleResetClick}>\n            Reset\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TopBar;\n","import React from 'react';\nimport './../styles/Legend.css';\n\nconst Legend = ({ name, img }) => {\n  return (\n    <span className='legendContainer'>\n      <span className={`legend ${name}Legend`}>\n        {img && (\n          <img className='legendImg' src={img} alt={img} draggable='false' />\n        )}\n      </span>\n      <span className='legendText'>{name}</span>\n    </span>\n  );\n};\n\nexport default Legend;\n","import React, { useState, useEffect } from 'react';\nimport Grid from './Grid.js';\nimport TopBar from './TopBar.js';\nimport Legend from './Legend.js';\nimport GridConstants from './../services/GridConstants.js';\nimport './../styles/App.css';\n\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\n\nfunction App() {\n  const [grid, setGrid] = useState(GridConstants.INITIAL_GRID);\n  const [startIsCovering, setStartIsCovering] = useState(\n    GridConstants.DEFAULT_SQ\n  );\n  const [endIsCovering, setEndIsCovering] = useState(GridConstants.DEFAULT_SQ);\n  const [algorithm, setAlgorithm] = useState(null);\n  const [speed, setSpeed] = useState('fast');\n  const [maze, setMaze] = useState(null);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isAnimatingFinished, setIsAnimatingFinished] = useState(false);\n\n  const resetGrid = () => {\n    setGrid(GridConstants.INITIAL_GRID);\n    setIsAnimatingFinished(false);\n    setStartIsCovering(GridConstants.DEFAULT_SQ);\n    setEndIsCovering(GridConstants.DEFAULT_SQ);\n    setAlgorithm(null);\n    setMaze(null);\n    setSpeed('fast');\n  };\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      const topBarHeight = document.getElementsByClassName('topBar')[0]\n        .offsetHeight;\n      const legendsHeight = document.getElementsByClassName(\n        'legendsContainer'\n      )[0].offsetHeight;\n      const gridMargin = 20;\n      GridConstants.update(\n        Math.floor((window.innerWidth - 25) / 25),\n        Math.floor(\n          (window.innerHeight - topBarHeight - legendsHeight - gridMargin) / 25\n        )\n      );\n      resetGrid();\n    };\n    updateDimensions();\n  }, []);\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (!isAnimating) {\n        const topBarHeight = document.getElementsByClassName('topBar')[0]\n          .offsetHeight;\n        const legendsHeight = document.getElementsByClassName(\n          'legendsContainer'\n        )[0].offsetHeight;\n        const gridMargin = 20;\n        GridConstants.update(\n          Math.floor((window.innerWidth - 25) / 25),\n          Math.floor(\n            (window.innerHeight - topBarHeight - legendsHeight - gridMargin) /\n              25\n          )\n        );\n        resetGrid();\n      }\n    };\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, [isAnimating]);\n\n  const legends = [\n    {\n      name: 'Start',\n      img: start,\n    },\n    {\n      name: 'End',\n      img: end,\n    },\n    {\n      name: 'Weight',\n      img: weight,\n    },\n    {\n      name: 'Wall',\n    },\n    {\n      name: 'Visited',\n    },\n    {\n      name: 'Path',\n    },\n  ];\n\n  const gridStyle = {\n    gridTemplateColumns: `repeat(${GridConstants.WIDTH}, 25px)`,\n    gridTemplateRows: `repeat(${GridConstants.HEIGHT}, 25px)`,\n  };\n\n  return (\n    <div className='page'>\n      <TopBar\n        grid={grid}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        setStartIsCovering={setStartIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        setIsAnimating={setIsAnimating}\n        setIsAnimatingFinished={setIsAnimatingFinished}\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        speed={speed}\n        setSpeed={setSpeed}\n        maze={maze}\n        setMaze={setMaze}\n      />\n      <div className='legendsContainer'>\n        {legends.map((legend) => (\n          <Legend key={legend.name} name={legend.name} img={legend.img} />\n        ))}\n      </div>\n      <Grid\n        grid={grid}\n        gridStyle={gridStyle}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        startIsCovering={startIsCovering}\n        setStartIsCovering={setStartIsCovering}\n        endIsCovering={endIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        isAnimating={isAnimating}\n        isAnimatingFinished={isAnimatingFinished}\n        algorithm={algorithm}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App className='page' />, document.getElementById('root'));\n"],"sourceRoot":""}