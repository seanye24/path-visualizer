{"version":3,"sources":["images/weight.svg","images/start.svg","images/end.svg","components/Square.js","services/Algorithms.js","services/Animations.js","components/Grid.js","components/Select.js","services/Maze.js","components/TopBar.js","components/App.js","index.js"],"names":["module","exports","React","memo","props","id","className","onMouseDown","onMouseUp","onMouseOver","onKeyDown","onKeyUp","tabIndex","Grid","WEIGHT_SQ","VISITED_WEIGHT_SQ","VISITED_FINISHED_WEIGHT_SQ","PATH_WEIGHT_SQ","PATH_FINISHED_WEIGHT_SQ","src","weight","draggable","alt","START_SQ","PATH_HEAD_SQ","start","END_SQ","end","grid","findIndex","sq","prev","visited","weights","Array","SIZE","fill","Number","MAX_SAFE_INTEGER","pq","console","log","currSquare","shift","push","moves","WIDTH","map","move","filter","nextSquare","validMove","moveWeight","WALL_SQ","includes","splice","indexOf","inserted","i","length","path","unshift","heuristic","Math","abs","floor","setGrid","dist","count","stack","pop","queue","clearAnimate","nextGrid","DEFAULT_SQ","animate","algorithm","speed","shouldDelay","a","pathDelay","visitedDelay","Promise","resolve","Algorithms","square","prevSquare","changeSquare","ind","squareType","VISITED_SQ","VISITED_HEAD_SQ","wait","VISITED_FINISHED_SQ","PATH_SQ","PATH_FINISHED_SQ","ms","setTimeout","getRow","getCol","getCoor","startIsCovering","setStartIsCovering","endIsCovering","setEndIsCovering","isAnimating","resetGrid","isAnimatingFinished","useState","isMouseDown","setIsMouseDown","isHoldingStart","setIsHoldingStart","isHoldingEnd","setIsHoldingEnd","isWDown","setIsWDown","mouseOver","setMouseOver","startSq","endSq","useEffect","Animations","e","key","renderSquare","HEIGHT","INITIAL_START","INITIAL_END","getSq","row","col","validMazeMove","endRow","endCol","Select","customSelectStyle","menu","provided","state","backgroundColor","width","border","margin","padding","menuList","borderRadius","container","height","display","alignItems","control","menuIsOpen","boxShadow","fontFamily","fontWeight","fontSize","cursor","userSelect","color","hasValue","dropdownIndicator","indicatorSeparator","placeholder","option","singleValue","whiteSpace","overflow","textOverflow","paddingRight","maxWidth","lineHeight","top","valueContainer","styles","options","value","label","optionsMap","onChange","data","isSearchable","tabSelectsValue","generateMaze","maze","finished","delay","randomMaze","dfs","recursiveDivision","kruskal","prim","drawRow","colRange","drawCol","rowRange","drawMazeBorder","generateWallGrid","getRandomElement","array","random","shuffleArray","newArray","getClosestEmptyTileFrom","from","reduce","closest","idx","closestDist","generateStartEndPosition","idealStart","idealEnd","Set","nextMove","nextMoves","has","add","divide","possibleRows","possibleRowHoles","possibleCols","possibleColHoles","randomRow","randomColHole","randomHole","randomCol","randomRowHole","treeSet","wallMap","iRow","iCol","Object","entries","wall","sq1","sq2","union","forEach","neighborSquares","neighborWalls","t","r","b","l","visitedSquares","visitedWalls","randomWall","TopBar","setIsAnimating","setIsAnimatingFinished","setAlgorithm","setMaze","setSpeed","setStartSq","setEndSq","Maze","promise","handleAlgorithmSubmit","event","preventDefault","algorithmsMap","dijkstra","astar","greedy","bfs","mazesMap","speedMap","slow","medium","fast","alg","keys","onClick","App","initialGrid","shouldResetSelects","ReactDOM","render","document","getElementById"],"mappings":"wIAAAA,EAAOC,QAAU,IAA0B,oC,gBCA3CD,EAAOC,QAAU,IAA0B,mC,gBCA3CD,EAAOC,QAAU,IAA0B,iC,+PC0C5BC,MAAMC,MAlCN,SAACC,GACd,OACE,yBACEC,GAAID,EAAMC,GACVC,UAAWF,EAAME,UACjBC,YAAaH,EAAMG,YACnBC,UAAWJ,EAAMI,UACjBC,YAAaL,EAAMK,YACnBC,UAAWN,EAAMM,UACjBC,QAASP,EAAMO,QACfC,UAAW,IACTR,EAAME,YAAcO,EAAKC,WACzBV,EAAME,YAAcO,EAAKE,mBACzBX,EAAME,YAAcO,EAAKG,4BACzBZ,EAAME,YAAcO,EAAKI,gBACzBb,EAAME,YAAcO,EAAKK,0BACzB,yBACEC,IAAKC,IACLd,UAAU,YACVe,UAAU,QACVC,IAAI,YAGNlB,EAAME,YAAcO,EAAKU,UACzBnB,EAAME,YAAcO,EAAKW,eACzB,yBAAKL,IAAKM,IAAOnB,UAAU,WAAWe,UAAU,QAAQC,IAAI,UAE7DlB,EAAME,YAAcO,EAAKa,QACxB,yBAAKP,IAAKQ,IAAKrB,UAAU,SAASe,UAAU,QAAQC,IAAI,Y,8BCwQjD,EA1SE,SAACM,GAChB,IAAMH,EAAQG,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YAC3CI,EAAMC,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UAEzCK,EAAO,GACPC,EAAU,GACVC,EAAU,IAAIC,MAAMrB,EAAKsB,MAAMC,KAAKC,OAAOC,kBACjDL,EAAQR,GAAS,EAGjB,IADA,IAAMc,EAAK,CAACd,GATa,aAWvBe,QAAQC,IAAI,qBACZ,IAAMC,EAAaH,EAAGI,QAEtB,GADAX,EAAQY,KAAKF,GACTA,IAAef,EACjB,cAEF,IAjBuB,EAiBjBkB,EAAQ,EAAE,EAAG,GAAIhC,EAAKiC,MAAOjC,EAAKiC,OAjBjB,cAkBED,EACtBE,KAAI,SAACC,GAAD,OAAUN,EAAaM,KAC3BC,QAAO,SAACC,GAAD,OAAgBrC,EAAKsC,UAAUT,EAAYQ,OApB9B,IAkBvB,2BAEmE,CAAC,IAFzDA,EAEwD,QAC7DE,EAAanB,EAAQS,GAGzB,GAAId,EAAKsB,KAAgBrC,EAAKwC,UAEnBzB,EAAKsB,KAAgBrC,EAAKC,UACnCsC,GAAc,GAEdA,GAAc,EAGZA,EAAanB,EAAQiB,KACvBjB,EAAQiB,GAAcE,EACtBrB,EAAKmB,GAAcR,EAEfH,EAAGe,SAASJ,IACdX,EAAGgB,OAAOhB,EAAGiB,QAAQN,GAAa,IAI/BlB,EAAQsB,SAASJ,KAAa,CAEjC,IADA,IAAIO,GAAW,EACNC,EAAI,EAAGA,EAAInB,EAAGoB,OAAQD,IAC7B,GAAIN,EAAanB,EAAQM,EAAGmB,IAAK,CAC/BnB,EAAGgB,OAAOG,EAAG,EAAGR,GAChBO,GAAW,EACX,MAGCA,GACHlB,EAAGK,KAAKM,KAnDO,gCAUlBX,EAAGoB,OAAS,GAAG,kBAKlB,MA8CJ,IAFA,IAAMC,EAAO,GACTlB,EAAaf,EACVe,GACLkB,EAAKC,QAAQnB,GACbA,EAAaX,EAAKW,GAEpB,MAAO,CAACV,EAAS4B,IAyOJ,EAtOD,SAAChC,GACb,IAAMH,EAAQG,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YAC3CI,EAAMC,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UAEzCK,EAAO,GACPC,EAAU,GACVC,EAAU,IAAIC,MAAMrB,EAAKsB,MAAMC,KAAKC,OAAOC,kBACjDL,EAAQR,GAAS,EAUjB,IARA,IAAMqC,EAAY,SAACrC,EAAOE,GACxB,OACEoC,KAAKC,IAAID,KAAKE,MAAMxC,EAAQZ,EAAKiC,OAASiB,KAAKE,MAAMtC,EAAMd,EAAKiC,QAChEiB,KAAKC,IAAKvC,EAAQZ,EAAKiC,MAAUnB,EAAMd,EAAKiC,QAI1CP,EAAK,CAACd,GAhBU,aAkBpBe,QAAQC,IAAI,iBACZ,IAAMC,EAAaH,EAAGI,QAEtB,GADAX,EAAQY,KAAKF,GACTA,IAAef,EACjB,cAEF,IAxBoB,EAwBdkB,EAAQ,EAAE,EAAG,GAAIhC,EAAKiC,MAAOjC,EAAKiC,OAxBpB,cAyBKD,EACtBE,KAAI,SAACC,GAAD,OAAUN,EAAaM,KAC3BC,QAAO,SAACC,GAAD,OAAgBrC,EAAKsC,UAAUT,EAAYQ,OA3BjC,IAyBpB,2BAEmE,CAAC,IAFzDA,EAEwD,QAC7DE,EAAanB,EAAQS,GACzB,GAAId,EAAKsB,KAAgBrC,EAAKwC,UAEnBzB,EAAKsB,KAAgBrC,EAAKC,UACnCsC,GAAc,GAEdA,GAAc,EAGZA,EAAanB,EAAQiB,KACvBjB,EAAQiB,GAAcE,EACtBrB,EAAKmB,GAAcR,EAEfH,EAAGe,SAASJ,IACdX,EAAGgB,OAAOhB,EAAGiB,QAAQN,GAAa,IAI/BlB,EAAQsB,SAASJ,KAAa,CAEjC,IADA,IAAIO,GAAW,EACNC,EAAI,EAAGA,EAAInB,EAAGoB,OAAQD,IAC7B,GACEN,EAAaU,EAAUZ,EAAYvB,GACnCM,EAAQM,EAAGmB,IAAMI,EAAUvB,EAAGmB,GAAI/B,GAClC,CACAY,EAAGgB,OAAOG,EAAG,EAAGR,GAChBO,GAAW,EACX,MAGCA,GACHlB,EAAGK,KAAKM,KA3DI,gCAiBfX,EAAGoB,OAAS,GAAG,kBAKlB,MA+CJ,IAFA,IAAIC,EAAO,GACPlB,EAAaf,EACVe,GACLkB,EAAKC,QAAQnB,GACbA,EAAaX,EAAKW,GAGpB,MAAO,CAACV,EAAS4B,IA4JJ,EAzJA,SAAChC,EAAMsC,GASpB,IARA,IAAMzC,EAAQG,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YAC3CI,EAAMC,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UAEzCK,EAAO,GACPC,EAAU,GACVC,EAAU,CAAER,MAAO,GAEnBc,EAAK,CAACd,GARoB,aAU9Be,QAAQC,IAAI,sBACZ,IAAMC,EAAaH,EAAGI,QAEtB,GADAX,EAAQY,KAAKF,GACTA,IAAef,EACjB,cAEF,IAhB8B,EAgBxBkB,EAAQ,EAAE,EAAG,GAAIhC,EAAKiC,MAAOjC,EAAKiC,OAhBV,cAiBLD,EACtBE,KAAI,SAACC,GAAD,OAAUN,EAAaM,KAC3BC,QAAO,SAACC,GAAD,OAAgBrC,EAAKsC,UAAUT,EAAYQ,OAnBvB,IAiB9B,2BAEmE,CAAC,IAFzDA,EAEwD,QAC7DE,EAAavC,EAAKsD,KAAKjB,EAAYvB,GAEvC,GAAIC,EAAKsB,KAAgBrC,EAAKwC,UAEnBzB,EAAKsB,KAAgBrC,EAAKC,YACnCsC,GAAc,KAIXb,EAAGe,SAASJ,KAAgBlB,EAAQsB,SAASJ,IAAa,CAC7DjB,EAAQiB,GAAcE,EACtBrB,EAAKmB,GAAcR,EAEnB,IADA,IAAIe,GAAW,EACNC,EAAI,EAAGA,EAAInB,EAAGoB,OAAQD,IAC7B,GAAIN,EAAanB,EAAQM,EAAGmB,IAAK,CAC/BnB,EAAGgB,OAAOG,EAAG,EAAGR,GAChBO,GAAW,EACX,MAGCA,GACHlB,EAAGK,KAAKM,KAzCgB,gCASzBX,EAAGoB,OAAS,GAAG,kBAKlB,MAqCJ,IAHA,IAAMC,EAAO,GACTlB,EAAaf,EACbyC,EAAQ,EACL1B,KACD0B,IAAUvD,EAAKsB,OAGnByB,EAAKC,QAAQnB,GACbA,EAAaX,EAAKW,GAEpB,MAAO,CAACV,EAAS4B,IA+FJ,EA5FH,SAAChC,GAQX,IAPA,IAAMH,EAAQG,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YAC3CI,EAAMC,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UAEzCK,EAAO,GACPC,EAAU,GAEVqC,EAAQ,CAAC5C,GAPK,aASlBe,QAAQC,IAAI,eACZ,IAAMC,EAAa2B,EAAMC,MAEzB,GADAtC,EAAQY,KAAKF,GACTA,IAAef,EACjB,cAEF,IAfkB,EAeZkB,EAAQ,EAAE,EAAG,GAAIhC,EAAKiC,MAAOjC,EAAKiC,OAftB,cAgBOD,EACtBE,KAAI,SAACC,GAAD,OAAUN,EAAaM,KAC3BC,QAAO,SAACC,GAAD,OAAgBrC,EAAKsC,UAAUT,EAAYQ,OAlBnC,IAgBlB,2BAEmE,CAAC,IAFzDA,EAEwD,QAE7DtB,EAAKsB,KAAgBrC,EAAKwC,UAKzBrB,EAAQsB,SAASJ,IAAgBmB,EAAMf,SAASJ,KACnDnB,EAAKmB,GAAcR,EACnB2B,EAAMzB,KAAKM,MA3BG,gCAQbmB,EAAMV,OAAS,GAAG,kBAKrB,MAuBJ,IAHA,IAAMC,EAAO,GACTlB,EAAaf,EACbyC,EAAQ,EACL1B,KACD0B,IAAUvD,EAAKsB,OAGnByB,EAAKC,QAAQnB,GACbA,EAAaX,EAAKW,GAEpB,MAAO,CAACV,EAAS4B,IAiDJ,EA9CH,SAAChC,GAQX,IAPA,IAAMH,EAAQG,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YAC3CI,EAAMC,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UAEzCK,EAAO,GACPC,EAAU,GAEVuC,EAAQ,CAAC9C,GAPK,aASlBe,QAAQC,IAAI,eACZ,IAAMC,EAAa6B,EAAM5B,QAEzB,GADAX,EAAQY,KAAKF,GACTA,IAAef,EACjB,cAEF,IAfkB,EAeZkB,EAAQ,EAAE,EAAG,GAAIhC,EAAKiC,MAAOjC,EAAKiC,OAftB,cAgBOD,EACtBE,KAAI,SAACC,GAAD,OAAUN,EAAaM,KAC3BC,QAAO,SAACC,GAAD,OAAgBrC,EAAKsC,UAAUT,EAAYQ,OAlBnC,IAgBlB,2BAEmE,CAAC,IAFzDA,EAEwD,QAE7DtB,EAAKsB,KAAgBrC,EAAKwC,UAKzBrB,EAAQsB,SAASJ,IAAgBqB,EAAMjB,SAASJ,KACnDnB,EAAKmB,GAAcR,EACnB6B,EAAM3B,KAAKM,MA3BG,gCAQbqB,EAAMZ,OAAS,GAAG,kBAKrB,MAuBJ,IAHA,IAAMC,EAAO,GACTlB,EAAaf,EACbyC,EAAQ,EACL1B,KACD0B,IAAUvD,EAAKsB,OAGnByB,EAAKC,QAAQnB,GACbA,EAAaX,EAAKW,GAEpB,MAAO,CAACV,EAAS4B,ICtSbY,EAAe,SAAC5C,EAAMsC,GAC1B,IAAMO,EAAW7C,EAAKmB,KAAI,SAACjB,GACzB,OAAIA,IAAOjB,EAAKU,UAAYO,IAAOjB,EAAKa,QAAUI,IAAOjB,EAAKwC,QACrDvB,EAEPA,IAAOjB,EAAKC,WACZgB,IAAOjB,EAAKE,mBACZe,IAAOjB,EAAKG,4BACZc,IAAOjB,EAAKI,gBACZa,IAAOjB,EAAKK,wBAELL,EAAKC,UAELD,EAAK6D,cAIhB,OADAR,EAAQO,GACDA,GAGHE,EAAO,uCAAG,WAAOC,EAAWhD,EAAMsC,EAASW,EAAOC,GAAxC,mEAAAC,EAAA,yDACVC,EAAY,IAEZF,EAHU,sBAIJD,EAJI,OAKL,SALK,OAOL,SAPK,OAUL,WAVK,OAaL,SAbK,kEAQRI,EAAe,IARP,mCAWRA,EAAe,GAXP,oCAcRA,EAAe,EAdP,sDAiBDC,QAAQC,SAAQ,IAjBf,QAoBd3C,QAAQC,IAAI,QAASoC,GApBP,KAsBND,EAtBM,OAuBP,aAvBO,QA2BP,UA3BO,QA+BP,WA/BO,QAmCP,QAnCO,QAuCP,QAvCO,gCAwBVhD,EAAO4C,EAAa5C,EAAMsC,GAxBhB,EAyBQkB,EAAoBxD,GAzB5B,mBAyBTI,EAzBS,KAyBA4B,EAzBA,yCA4BVhC,EAAO4C,EAAa5C,EAAMsC,GA5BhB,EA6BQkB,EAAiBxD,GA7BzB,mBA6BTI,EA7BS,KA6BA4B,EA7BA,yCAgCVhC,EAAO4C,EAAa5C,EAAMsC,GAhChB,EAiCQkB,EAAkBxD,GAjC1B,mBAiCTI,EAjCS,KAiCA4B,EAjCA,yCAoCVhC,EAAO4C,EAAa5C,EAAMsC,GApChB,EAqCQkB,EAAexD,GArCvB,mBAqCTI,EArCS,KAqCA4B,EArCA,yCAwCVhC,EAAO4C,EAAa5C,EAAMsC,GAxChB,EAyCQkB,EAAexD,GAzCvB,mBAyCTI,EAzCS,KAyCA4B,EAzCA,2DA4CHsB,QAAQC,SAAQ,IA5Cb,QA+CR1D,EAAQG,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YAC3CI,EAAMC,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UAC/CM,EAAUA,EAAQiB,QAAO,SAACoC,GAAD,OAAYA,IAAW5D,GAAS4D,IAAW1D,KACpEiC,EAAOA,EAAKX,QAAO,SAACoC,GAAD,OAAYA,IAAW5D,GAAS4D,IAAW1D,KAG1D2D,EAAa,KArDH,cAsDOtD,GAtDP,8DAsDHqD,EAtDG,SAuDRP,EAvDQ,wBAwDNQ,IACF1D,EAAO2D,EACL3D,EACAsC,EACAoB,EAAWE,IACXF,EAAWG,aAGTA,EACJ7D,EAAKyD,KAAYxE,EAAKC,UAClBD,EAAKE,kBACLF,EAAK6E,WACX9D,EAAO2D,EAAa3D,EAAMsC,EAASmB,EAAQxE,EAAK8E,iBAChDL,EAAa,CAAEE,IAAKH,EAAQI,WAAYA,GArE9B,UAsEJG,EAAKX,GAtED,gCAwEJQ,EACJ7D,EAAKyD,KAAYxE,EAAKC,UAClBD,EAAKG,2BACLH,EAAKgF,oBACXjE,EAAO2D,EAAa3D,EAAMsC,EAASmB,EAAQI,GA5EjC,iJA+EVX,IACFlD,EAAO2D,EAAa3D,EAAMsC,EAASoB,EAAWE,IAAKF,EAAWG,aAIhEH,EAAa,KApFC,cAqFO1B,GArFP,8DAqFHyB,EArFG,SAsFRP,EAtFQ,wBAuFNQ,IACF1D,EAAO2D,EACL3D,EACAsC,EACAoB,EAAWE,IACXF,EAAWG,aAGTA,EACJ7D,EAAKyD,KAAYxE,EAAKE,kBAClBF,EAAKI,eACLJ,EAAKiF,QACXlE,EAAO2D,EAAa3D,EAAMsC,EAASmB,EAAQxE,EAAKW,cAChD8D,EAAa,CAAEE,IAAKH,EAAQI,WAAYA,GApG9B,UAqGJG,EAAKZ,GArGD,gCAuGJS,EACJ7D,EAAKyD,KAAYxE,EAAKG,2BAClBH,EAAKK,wBACLL,EAAKkF,iBACXnE,EAAO2D,EAAa3D,EAAMsC,EAASmB,EAAQI,GA3GjC,iLA8GPP,QAAQC,SAAQ,IA9GT,mFAAH,8DAiHPS,EAAO,SAACI,GAAD,OAAQ,IAAId,SAAQ,SAACC,GAAD,OAAac,WAAWd,EAASa,OAE5DT,EAAe,SAAC3D,EAAMsC,EAASmB,EAAQI,GAC3C,IAAMhB,EAAQ,YAAO7C,GAGrB,OAFA6C,EAASY,GAAUI,EACnBvB,EAAQO,GACDA,GAGM,GAAEE,WCrIXjD,EAAS,YAcTwE,EAAS,SAACpE,GACd,OAAOiC,KAAKE,MAAMnC,EAtBN,KAyBRqE,EAAS,SAACrE,GACd,OAAOA,EA1BK,IA6BRsE,EAAU,SAACtE,GACf,MAAO,CAACoE,EAAOpE,GAAKqE,EAAOrE,KAUvBqB,EAAY,SAAC1B,EAAOE,GACxB,OAAOA,EAvCImB,MAuCUnB,GAAO,GAAKoC,KAAKC,IAAImC,EAAOxE,GAAOwE,EAAO1E,KAAW,GAqI7D,GACbZ,KAxHW,SAAC,GAWP,IAVLe,EAUI,EAVJA,KACAsC,EASI,EATJA,QACAmC,EAQI,EARJA,gBACAC,EAOI,EAPJA,mBACAC,EAMI,EANJA,cACAC,EAKI,EALJA,iBAEAC,GAGI,EAJJC,UAII,EAHJD,aACAE,EAEI,EAFJA,oBACA/B,EACI,EADJA,UACI,EACkCgC,oBAAS,GAD3C,mBACGC,EADH,KACgBC,EADhB,OAEwCF,oBAAS,GAFjD,mBAEGG,EAFH,KAEmBC,EAFnB,OAGoCJ,oBAAS,GAH7C,mBAGGK,EAHH,KAGiBC,EAHjB,OAI0BN,oBAAS,GAJnC,mBAIGO,EAJH,KAIYC,EAJZ,OAK8BR,oBAAU,GALxC,mBAKGS,EALH,KAKcC,EALd,KAOEC,EAAU3F,EAAKC,WAAU,SAACC,GAAD,MAnEhB,gBAmEwBA,KACjC0F,EAAQ5F,EAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOJ,KAE5C+F,qBAAU,WACR,GAAIZ,IAAgBJ,EAAa,CAC/B,IAAMhC,EAAQ,YAAO7C,GACrB,GACEmF,GACAM,IAAcE,GACd3F,EAAKyF,KAAe3F,GAMpB,GAJA+C,EAAS8C,GAAWlB,EACpBC,EAAmB1E,EAAKyF,IACxB5C,EAAS4C,GAhFA,cAkFLV,EAEF,YADAe,EAAW/C,QAAQC,EAAWH,EAAUP,EAAS,QAAQ,QAGtD,GACL+C,GACAI,IAAcG,GAxFL,gBAyFT5F,EAAKyF,IAML,GAJA5C,EAAS+C,GAASjB,EAClBC,EAAiB5E,EAAKyF,IACtB5C,EAAS4C,GAAa3F,EAElBiF,EAEF,YADAe,EAAW/C,QAAQC,EAAWH,EAAUP,EAAS,QAAQ,QAGlDiD,GAAWE,IAAcE,GAAWF,IAAcG,EAC3D/C,EAAS4C,GAjGC,iBAkGRzF,EAAKyF,GAtGI,SAID,eAmGDA,IAAcE,GAAWF,IAAcG,IAChD/C,EAAS4C,GArGD,eAsGNzF,EAAKyF,GAzGI,SAGH,cAwGVnD,EAAQO,MAET,CAACoC,EAAaQ,IAEjB,IAwBM3G,EAAY,SAACiH,GACH,MAAVA,EAAEC,KACJR,GAAW,IAITzG,EAAU,SAACgH,GACD,MAAVA,EAAEC,KACJR,GAAW,IAITS,EAAe,SAAC/F,EAAIzB,GACxB,OACE,kBAAC,EAAD,CACEuH,IAAKvH,EACLA,GAAIA,EACJC,UAAWwB,EACXvB,YAAa,kBAjCC,SAACF,GACnBmC,QAAQC,IAAI,MAAO8E,EAASC,GAC5BhF,QAAQC,IAAI,MAAOb,EAAK2F,IACpBlH,IAAOkH,EACTP,GAAkB,GACT3G,IAAOmH,GAChBN,GAAgB,GAElBJ,GAAe,GAyBQvG,CAAYF,IAC/BG,UAAW,kBA1CXuG,EACFC,GAAkB,GACTC,GACTC,GAAgB,QAElBJ,GAAe,IAsCXrG,YAAa,kBAxBC,SAACJ,GACnBiH,EAAajH,GAuBUI,CAAYJ,IAC/BK,UAAWA,EACXC,QAASA,KASf,OAAO,yBAAKL,UAAU,QAHbsB,EAAKmB,KAAI,SAACjB,EAAI0D,GAAL,OAAaqC,EAAa/F,EAAI0D,QAQhD1C,MAhLY,GAiLZgF,OAhLa,GAiLb3F,KAhLWW,KAiLXiF,cAhLoB,KAiLpBC,YAhLkB,KAiLlBtD,WAhLiB,SAiLjBnD,SAhLe,cAiLfG,SACA2B,QAhLc,aAiLdvC,UAhLgB,eAiLhB4E,WAhLiB,gBAiLjB3E,kBAhLwB,sBAiLxB4E,gBAhLsB,oBAiLtBE,oBAhL0B,wBAiL1B7E,2BAhLiC,8BAiLjC8E,QAhLc,aAiLd7E,eAhLqB,mBAiLrBO,aAhLmB,iBAiLnBuE,iBAhLuB,qBAiLvB7E,wBAhL8B,2BAiL9BgF,SACAC,SACAC,UACA6B,MAtKY,SAACC,EAAKC,GAClB,OAlCY,GAkCLD,EAAcC,GAsKrBhE,KAnKW,SAAC1C,EAAOE,GAAR,OACXoC,KAAKC,IAAIkC,EAAOzE,GAASyE,EAAOvE,IAAQoC,KAAKC,IAAImC,EAAO1E,GAAS0E,EAAOxE,KAmKxEwB,YACAiF,cA9JoB,SAAC3G,EAAOE,GAAS,IAAD,EACXyE,EAAQzE,GADG,mBAC7B0G,EAD6B,KACrBC,EADqB,KAEpC,OACED,GAAU,GACVA,EAASP,IACTQ,GAAU,GACVA,EAASxF,IACTK,EAAU1B,EAAOE,K,eCoDN4G,G,MAxGA,SAACnI,GACd,IAAMoI,EAAoB,CACxBC,KAAM,SAACC,EAAUC,GAAX,mBAAC,eACFD,GADC,IAEJE,gBAAiB,oBACjBC,MAAO,QACPC,OAAQ,OACRC,OAAQ,MACRC,QAAS,SAEXC,SAAU,SAACP,EAAUC,GAAX,mBAAC,eACND,GADK,IAERM,QAAS,MACTE,aAAc,qBAEhBC,UAAW,SAACT,EAAUC,GAAX,mBAAC,eACPD,GADM,IAETU,OAAQ,OACRL,OAAQ,YACRM,QAAS,OACTC,WAAY,YAEdC,QAAS,SAACb,EAAUC,GAAX,mBAAC,eACLD,GADI,IAEPG,MAAO,QACPO,OAAQ,OACRN,OAAQ,OACRI,aAAcP,EAAMa,WAAa,kBAAoB,MACrDC,UAAW,OACXC,WAAY,qBACZC,WAAY,IACZC,SAAU,OACVC,OAAQ,UACRC,WAAY,OAEZC,MAAO,QACPnB,gBACED,EAAMqB,UAAYrB,EAAMa,WACpB,oBACA,cACN,UAAW,CACTZ,gBAAiB,oBACjBmB,MAAO,QACPjB,OAAQ,WAGZmB,kBAAmB,SAACvB,EAAUC,GAAX,MAAsB,CACvCI,OAAQ,QAEVmB,mBAAoB,SAACxB,GAAD,MAAe,IACnCyB,YAAa,SAACzB,EAAUC,GAAX,MAAsB,IACnCyB,OAAQ,SAAC1B,EAAUC,GAAX,mBAAC,eACJD,GADG,IAENmB,OAAQ,UACRH,WAAY,qBACZC,WAAY,IAEZI,MAAO,QACPnB,gBAAiB,oBACjB,UAAW,CACTmB,MAAO,kBACPnB,gBAAiB,yBAGrByB,YAAa,SAAC3B,GAAD,mBAAC,eACTA,GADQ,IAEX4B,WAAY,SACZC,SAAU,SACVC,aAAc,WACdC,aAAc,MACdC,SAAU,OACV7B,MAAO,OACPO,OAAQ,OACRuB,WAAY,OACZC,IAAK,MACLb,MAAO,MAETc,eAAgB,SAACnC,GAAD,mBAAC,eACZA,GADW,IAEdU,OAAQ,WAIZ,OACE,kBAAC,IAAD,CACE0B,OAAQtC,EACRuC,QAAS3K,EAAM2K,QAAQhI,KAAI,SAACqH,GAAD,MAAa,CACtCY,MAAOZ,EACPa,MAAO7K,EAAM8K,WAAWd,OAE1BY,MACE5K,EAAMgK,QAAU,CACdY,MAAO5K,EAAMgK,OACba,MAAO7K,EAAM8K,WAAW9K,EAAMgK,SAGlCe,SAAU,SAACC,GAAD,OAAUhL,EAAM+K,SAASC,EAAKJ,QACxCb,YAAa/J,EAAM+J,YACnBkB,cAAc,EACdC,iBAAiB,MCrGjBC,EAAY,uCAAG,WAAOC,EAAM5J,EAAMsC,EAASwC,EAAW7B,GAAvC,eAAAE,EAAA,yDACdyG,EADc,yCAEVtG,QAAQC,QAAQ,CAAEsG,UAAU,EAAO7J,KAAMA,KAF/B,OAInBA,EAAO,IAAIM,MAAMrB,EAAKsB,MAAMC,KAAKvB,EAAK6D,YACtCR,EAAQtC,GACRY,QAAQC,IAAI,kBAAmB+I,GAC3BE,EAAQ,EAPO,KASXF,EATW,OAUZ,WAVY,OAYZ,QAZY,QAcZ,sBAdY,QAgBZ,YAhBY,QAkBZ,SAlBY,yCAWFG,EAAW/J,EAAMsC,EAASwH,GAXxB,kEAaFE,EAAIhK,EAAMsC,EAASwH,GAbjB,kEAeFG,EAAkBjK,EAAMsC,EAASwH,GAf/B,kEAiBFI,GAAQlK,EAAMsC,EAASwH,GAjBrB,kEAmBFK,GAAKnK,EAAMsC,EAASwH,GAnBlB,qFAAH,8DAwBZnG,EAAe,SAAC3D,EAAMsC,EAASmB,EAAQI,GAC3C,IAAMhB,EAAQ,YAAO7C,GAGrB,OAFA6C,EAASY,GAAUI,EACnBvB,EAAQO,GACDA,GAGHmB,EAAO,SAACI,GAAD,OACXA,EAAK,IAAId,SAAQ,SAACC,GAAD,OAAac,WAAWd,EAASa,MAAOA,GAErDgG,EAAO,uCAAG,WAAOpK,EAAMsC,EAASwH,EAAOxD,EAAK+D,GAAlC,iBAAAlH,EAAA,sDACLrB,EAAIuI,EAAS,GADR,YACYvI,GAAKuI,EAAS,IAD1B,uBAENnK,EAAKoG,EAAMrH,EAAKiC,MAAQY,EAC9B9B,EAAO2D,EAAa3D,EAAMsC,EAASpC,EAAIjB,EAAKwC,SAHhC,SAINuC,EAAK8F,GAJC,OAC8BhI,IAD9B,+CAMPwB,QAAQC,QAAQvD,IANT,4CAAH,8DASPsK,EAAO,uCAAG,WAAOtK,EAAMsC,EAASwH,EAAOvD,EAAKgE,GAAlC,iBAAApH,EAAA,sDACLrB,EAAIyI,EAAS,GADR,YACYzI,GAAKyI,EAAS,IAD1B,uBAENrK,EAAK4B,EAAI7C,EAAKiC,MAAQqF,EAC5BvG,EAAO2D,EAAa3D,EAAMsC,EAASpC,EAAIjB,EAAKwC,SAHhC,SAINuC,EAAK8F,GAJC,OAC8BhI,IAD9B,+CAMPwB,QAAQC,QAAQvD,IANT,4CAAH,8DASPwK,EAAc,uCAAG,WAAOxK,EAAMsC,EAASwH,GAAtB,iBAAA3G,EAAA,sDACrB,IAASrB,EAAI,EAAGA,EAAI7C,EAAKiC,MAAOY,IAC9B9B,EAAO2D,EAAa3D,EAAMsC,EAASrD,EAAKoH,MAAM,EAAGvE,GAAI7C,EAAKwC,SAC1DzB,EAAO2D,EACL3D,EACAsC,EACArD,EAAKoH,MAAMpH,EAAKiH,OAAS,EAAGpE,GAC5B7C,EAAKwC,SAIT,IAASK,EAAI,EAAGA,EAAI7C,EAAKiH,OAAS,EAAGpE,IACnC9B,EAAO2D,EAAa3D,EAAMsC,EAASrD,EAAKoH,MAAMvE,EAAG,GAAI7C,EAAKwC,SAC1DzB,EAAO2D,EACL3D,EACAsC,EACArD,EAAKoH,MAAMvE,EAAG7C,EAAKiC,MAAQ,GAC3BjC,EAAKwC,SAjBY,yBAqBd6B,QAAQC,QAAQvD,IArBF,2CAAH,0DAwBdyK,EAAmB,SAACzK,EAAMsC,GAC9B,IAAK,IAAIgE,EAAM,EAAGA,EAAMrH,EAAKiH,OAAQI,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMtH,EAAKiC,MAAOqF,IAEhCvG,EAAO2D,EACL3D,EACAsC,EACArD,EAAKoH,MAAMC,EAAKC,GAJhBD,EAAM,GAAKC,EAAM,EAKjBtH,EAAK6D,WAGkD7D,EAAKwC,SAIpE,OAAOzB,GAOH0K,EAAmB,SAACC,GACxB,OAAOA,EAAMhJ,QALiB9B,EAKa,EALNE,EAKS4K,EAAM5I,OAAS,EAJtDI,KAAKE,MAAMF,KAAKyI,UAAY7K,EAAMF,EAAQ,IAAMA,GAIU,GAAG,GALvC,IAACA,EAAOE,GAQjC8K,EAAe,SAACF,GAEpB,IADA,IAAMG,EAAW,GACVH,EAAM5I,OAAS,GACpB+I,EAAS9J,KAAK0J,EAAiBC,IAEjC,OAAOG,GAGHC,EAA0B,SAAC/K,EAAMgL,GACrC,OAAOhL,EAAKiL,QAAO,SAACC,EAAShL,EAAIiL,GAC/B,GAAIjL,IAAOjB,EAAK6D,WAAY,CAC1B,IAAiB,IAAboI,EACF,OAAOC,EAEP,IAAMC,EAAcnM,EAAKsD,KAAKyI,EAAME,GAEpC,OADejM,EAAKsD,KAAKyI,EAAMG,GACfC,EAAcD,EAAMD,EAGtC,OAAOA,KAEP,IAGAG,EAA2B,SAACrL,EAAMsC,EAASgJ,EAAYC,GAC3D,IAAM1L,EAAQkL,EAAwB/K,EAAMsL,GACtCvL,EAAMgL,EAAwB/K,EAAMuL,GAE1C,OADAvL,EAAO2D,EAAa3D,EAAMsC,EAASzC,EAAOZ,EAAKU,UACxCgE,EAAa3D,EAAMsC,EAASvC,EAAKd,EAAKa,SAGzCiK,EAAU,uCAAG,WAAO/J,EAAMsC,EAASwH,GAAtB,eAAA3G,EAAA,sEACJqH,EAAexK,EAAMsC,EAASwH,GAD1B,OAEjB,IADA9J,EADiB,OAER8B,EAAI,EAAGA,EAAI9B,EAAK+B,OAAQD,IAC3B7C,EAAKuH,cAAc1E,EAAGA,IAAMK,KAAKyI,SAAW,MAE9C5K,EAAK8B,GAAK7C,EAAKwC,SALF,OAQjBa,EAAQtC,GARS,SASXgE,EAAK8F,GATM,cAUjB9J,EAAOqL,EACLrL,EACAsC,EACArD,EAAKoH,MAAM,EAAG,GACdpH,EAAKoH,MAAMpH,EAAKsB,KAAO,EAAGtB,EAAKsB,KAAO,IAdvB,kBAgBV+C,QAAQC,QAAQ,CAAEsG,UAAU,EAAO7J,KAAMA,KAhB/B,2CAAH,0DAmBVgK,EAAG,uCAAG,WAAOhK,EAAMsC,EAASwH,GAAtB,qBAAA3G,EAAA,sDACVnD,EAAOyK,EAAiBzK,EAAMsC,GACxBzC,EAAQZ,EAAKoH,MAAM,EAAG,GACtBjG,EAAU,IAAIoL,IAAI,CAAC3L,IACnBmC,EAAO,CAACnC,GAJJ,IAAAsD,EAAA,wCAAAA,EAAA,sDAMFrC,EAAakB,EAAKU,MAExBzB,GADIA,EAAQ,EAAE,EAAG,GAAI,EAAIhC,EAAKiC,MAAO,EAAIjC,EAAKiC,QAChCG,QAAO,SAACD,GAAD,OACnBnC,EAAKuH,cAAc1F,EAAYA,EAAaM,MATtC,YAYDH,EAAMc,OAAS,GAZd,oBAaA0J,EACJ3K,EAAaG,EAAMU,OAAOQ,KAAKyI,SAAW3J,EAAMc,OAAQ,GAAG,GACvD2J,EAAY,EAAE5K,EAAa2K,GAAY,EAAGA,GAC3CrL,EAAQuL,IAAIF,GAhBX,wBAiBJzL,EAAO2D,EAAa3D,EAAMsC,EAASoJ,EAAU,GAAIzM,EAAK6D,YAjBlD,UAkBEkB,EAAK8F,GAlBP,eAmBJ9J,EAAO2D,EAAa3D,EAAMsC,EAASoJ,EAAU,GAAIzM,EAAK6D,YAnBlD,UAoBEkB,EAAK8F,GApBP,eAqBJ1J,EAAQwL,IAAIH,GACZzJ,EAAKhB,KAAKyK,GACVzJ,EAAKhB,KAAKyK,GAvBN,mGAKHzJ,EAAKD,OAAS,GALX,uFA8BV/B,EAAOqL,EACLrL,EACAsC,EACArD,EAAKoH,MAAM,EAAG,GACdpH,EAAKoH,MAAMpH,EAAKsB,KAAO,EAAGtB,EAAKsB,KAAO,IAlC9B,kBAoCH+C,QAAQC,QAAQ,CAAEsG,UAAU,EAAO7J,KAAMA,KApCtC,4CAAH,0DAuCHiK,EAAiB,uCAAG,WAAOjK,EAAMsC,EAASwH,GAAtB,SAAA3G,EAAA,sEACXqH,EAAexK,EAAMsC,EAASwH,GADnB,cACxB9J,EADwB,gBAEX6L,EACX7L,EACAsC,EACAwH,EACA,CAAC,EAAG7K,EAAKiH,OAAS,GAClB,CAAC,EAAGjH,EAAKiC,MAAQ,IAPK,cAExBlB,EAFwB,OASxBA,EAAOqL,EACLrL,EACAsC,EACArD,EAAKoH,MAAM,EAAG,GACdpH,EAAKoH,MAAMpH,EAAKiH,OAAS,EAAGjH,EAAKiC,MAAQ,IAbnB,kBAejBoC,QAAQC,QAAQ,CAAEsG,UAAU,EAAO7J,KAAMA,KAfxB,2CAAH,0DAkBjB6L,EAAM,uCAAG,WAAO7L,EAAMsC,EAASwH,EAAOS,EAAUF,GAAvC,qCAAAlH,EAAA,sDAGb,IAFO2I,EAAmC,GAArBC,EAAyB,GACvCC,EAAmC,GAArBC,EAAyB,GACrCnK,EAAIyI,EAAS,GAAK,EAAGzI,EAAIyI,EAAS,GAAIzI,KACxCA,EAAIyI,EAAS,IAAM,IAAM,EAC5BuB,EAAa9K,KAAKc,GAElBiK,EAAiB/K,KAAKc,GAG1B,IAASA,EAAIuI,EAAS,GAAK,EAAGvI,EAAIuI,EAAS,GAAIvI,KACxCA,EAAIuI,EAAS,IAAM,IAAM,EAC5B2B,EAAahL,KAAKc,GAElBmK,EAAiBjL,KAAKc,GAdb,GAkBe,IAAxBgK,EAAa/J,QAAwC,IAAxBiK,EAAajK,OAlBjC,yCAmBJuB,QAAQC,QAAQvD,IAnBZ,YAqBP8L,EAAa/J,QAAUiK,EAAajK,QArB7B,wBAsBHmK,EAAYxB,EAAiBoB,GAtB1B,UAuBI1B,EAAQpK,EAAMsC,EAASwH,EAAOoC,EAAW7B,GAvB7C,eAuBTrK,EAvBS,OAwBHmM,EAAgBzB,EAAiBuB,GACjCG,EAAaF,EAAYjN,EAAKiC,MAAQiL,EAC5CnM,EAAO2D,EAAa3D,EAAMsC,EAAS8J,EAAYnN,EAAK6D,YA1B3C,UA2BHkB,EAAK8F,GA3BF,yBA4BI+B,EACX7L,EACAsC,EACAwH,EACA,CAACS,EAAS,GAAI2B,GACd7B,GAjCO,eA4BTrK,EA5BS,iBAmCI6L,EACX7L,EACAsC,EACAwH,EACA,CAACoC,EAAW3B,EAAS,IACrBF,GAxCO,QAmCTrK,EAnCS,sCA2CLqM,EAAY3B,EAAiBsB,GA3CxB,UA4CI1B,EAAQtK,EAAMsC,EAASwH,EAAOuC,EAAW9B,GA5C7C,eA4CTvK,EA5CS,OA6CHsM,EAAgB5B,EAAiBqB,GACjCK,EAAaE,EAAgBrN,EAAKiC,MAAQmL,EA9CvC,UA+CI1I,EAAa3D,EAAMsC,EAAS8J,EAAYnN,EAAK6D,YA/CjD,eA+CT9C,EA/CS,iBAgDI6L,EAAO7L,EAAMsC,EAASwH,EAAOS,EAAU,CAClDF,EAAS,GACTgC,IAlDO,eAgDTrM,EAhDS,iBAoDI6L,EAAO7L,EAAMsC,EAASwH,EAAOS,EAAU,CAClD8B,EACAhC,EAAS,KAtDF,QAoDTrK,EApDS,wCAyDJsD,QAAQC,QAAQvD,IAzDZ,4CAAH,8DA6DNkK,GAAO,uCAAG,WAAOlK,EAAMsC,EAASwH,GAAtB,yCAAA3G,EAAA,sDAKd,IAJAnD,EAAOyK,EAAiBzK,EAAMsC,GAC1BiK,EAAU,GACVC,EAAU,GAEL1K,EAAI,EAAGA,EAAI7C,EAAKsB,KAAMuB,IAAM,EACd7C,EAAKuF,QAAQ1C,GADA,mBAC3B2K,EAD2B,KACrBC,EADqB,KAE9BzN,EAAKuH,cAAc1E,EAAGA,KACpB2K,EAAO,GAAKC,EAAO,EACrBH,EAAQzK,GAAK,IAAI0J,IAAI,CAAC1J,IAElB4K,EAAO,EACTF,EAAQ1K,GAAK,CAACA,EAAI7C,EAAKiC,MAAOY,EAAI7C,EAAKiC,OAC9BuL,EAAO,IAChBD,EAAQ1K,GAAK,CAACA,EAAI,EAAGA,EAAI,KAdnB,cAoBmB+I,EAAa8B,OAAOC,QAAQJ,KApB/C,qFAoBFK,EApBE,2BAoBKC,EApBL,KAoBUC,EApBV,KAqBPR,EAAQO,GAAKnB,IAAIoB,GArBV,0CAAA5J,EAAA,kCAAAA,EAAA,6DAsBVnD,EAAO2D,EAAa3D,EAAMsC,EAASuK,EAAM5N,EAAK6D,YAtBpC,SAuBJkB,EAAK8F,GAvBD,OAwBJkD,EAAQ,IAAIxB,IAAJ,sBAAYe,EAAQO,IAApB,YAA6BP,EAAQQ,MACnDR,EAAQO,GAAKG,SAAQ,SAAC/M,GAAD,OAASqM,EAAQrM,GAAM8M,KAC5CT,EAAQQ,GAAKE,SAAQ,SAAC/M,GAAD,OAASqM,EAAQrM,GAAM8M,KA1BlC,2MA8BdhN,EAAOqL,EACLrL,EACAsC,EACArD,EAAKoH,MAAM,EAAG,GACdpH,EAAKoH,MAAMpH,EAAKiH,OAAS,EAAGjH,EAAKiC,MAAQ,IAlC7B,kBAoCPoC,QAAQC,QAAQ,CAAEsG,UAAU,EAAO7J,KAAMA,KApClC,gEAAH,0DAuCPmK,GAAI,uCAAG,WAAOnK,EAAMsC,EAASwH,GAAtB,+CAAA3G,EAAA,sDAKX,IAJAnD,EAAOyK,EAAiBzK,EAAMsC,GAC1B4K,EAAkB,GAClBC,EAAgB,GAEXrL,EAAI,EAAGA,EAAI7C,EAAKsB,KAAMuB,IACzB7C,EAAKuH,cAAc1E,EAAGA,KAAK,EACR7C,EAAKuF,QAAQ1C,GADN,mBACrB2K,EADqB,KACfC,EADe,KAExBD,EAAO,GAAKC,EAAO,GACfU,EAAInO,EAAKuH,cAAc1E,EAAGA,EAAI7C,EAAKiC,OAAS,CAACY,EAAI7C,EAAKiC,OAAS,GAC/DmM,EAAIpO,EAAKuH,cAAc1E,EAAGA,EAAI,GAAK,CAACA,EAAI,GAAK,GAC7CwL,EAAIrO,EAAKuH,cAAc1E,EAAGA,EAAI7C,EAAKiC,OAAS,CAACY,EAAI7C,EAAKiC,OAAS,GAC/DqM,EAAItO,EAAKuH,cAAc1E,EAAGA,EAAI,GAAK,CAACA,EAAI,GAAK,GACnDqL,EAAcrL,GAAd,UAAuBsL,EAAMC,EAAMC,EAAMC,IAChCd,EAAO,EAAIC,EAAO,IACvBA,EAAO,EACTQ,EAAgBpL,GAAK,CAACA,EAAI7C,EAAKiC,MAAOY,EAAI7C,EAAKiC,OACtCuL,EAAO,IAChBS,EAAgBpL,GAAK,CAACA,EAAI,EAAGA,EAAI,MAMnC0L,EAAiB,IAAIhC,IAAI,CAACvM,EAAKoH,MAAM,EAAG,KAC1CoH,EAzBO,YAyBYN,EAAclO,EAAKoH,MAAM,EAAG,KAzBxC,YA0BJoH,EAAa1L,OAAS,GA1BlB,oBA2BH2L,EAAahD,EAAiB+C,GA3B3B,cA4BUP,EAAgBQ,GA5B1B,GA4BFZ,EA5BE,KA4BGC,EA5BH,KA6BLD,EAAM7N,EAAKsB,MAActB,EAAKsB,OAE9BiN,EAAe7B,IAAImB,GAAOU,EAAe7B,IAAIoB,IA/BxC,wBAgCFS,EAAe7B,IAAImB,IAItBU,EAAe5B,IAAImB,GACnBU,EAAY,sBAAOA,GAAP,YAAwBN,EAAcJ,OAJlDS,EAAe5B,IAAIkB,GACnBW,EAAY,sBAAOA,GAAP,YAAwBN,EAAcL,MAKpD9M,EAAO2D,EAAa3D,EAAMsC,EAASoL,EAAYzO,EAAK6D,YAvC7C,UAwCDkB,EAAK8F,GAxCJ,sCA4CX9J,EAAOqL,EACLrL,EACAsC,EACArD,EAAKoH,MAAM,EAAG,GACdpH,EAAKoH,MAAMpH,EAAKiH,OAAS,EAAGjH,EAAKiC,MAAQ,IAhDhC,kBAkDJoC,QAAQC,QAAQ,CAAEsG,UAAU,EAAO7J,KAAMA,KAlDrC,4CAAH,0DAqDK,IAAE2J,gBClNFgE,GAnJA,SAACnP,GAAW,IAEvBwB,EAcExB,EAdFwB,KACAsC,EAaE9D,EAbF8D,QACAwC,EAYEtG,EAZFsG,UACA8I,EAWEpP,EAXFoP,eACAC,EAUErP,EAVFqP,uBACA7K,EASExE,EATFwE,UACA8K,EAQEtP,EARFsP,aACAlE,EAOEpL,EAPFoL,KACAmE,EAMEvP,EANFuP,QACA9K,EAKEzE,EALFyE,MACA+K,EAIExP,EAJFwP,SACAnJ,EAGErG,EAHFqG,YACAoJ,EAEEzP,EAFFyP,WACAC,EACE1P,EADF0P,SAGFrI,qBAAU,WACR,sBAAC,gCAAA1C,EAAA,yDACM0B,EADN,wBAEG+I,GAAe,GAFlB,SAGyBO,GAAKxE,aAAaC,EAAM5J,EAAMsC,EAASwC,GAHhE,OAGSsJ,EAHT,OAIGR,EAAeQ,EAAQvE,UACjBhK,EAAQuO,EAAQpO,KAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKU,YACnDI,EAAMqO,EAAQpO,KAAKC,WAAU,SAACC,GAAD,OAAQA,IAAOjB,EAAKa,UACvDc,QAAQC,IAAIhB,EAAOE,GACnBkO,EAAWpO,GACXqO,EAASnO,GACT8N,GAAuB,GAV1B,2CAAD,KAaC,CAACjE,IAEJ,IAAMyE,EAAqB,uCAAG,WAAOC,GAAP,eAAAnL,EAAA,yDAC5BmL,EAAMC,iBACD1J,EAFuB,uBAG1B+I,GAAe,GAHW,SAIA9H,EAAW/C,QACnCC,EACAhD,EACAsC,EACAW,GACA,GATwB,OAIpB4B,EAJoB,OAW1B+I,EAAe/I,GACfgJ,GAAwBhJ,GAZE,2CAAH,sDAmCrB2J,EAAgB,CACpBC,SAAU,WACVC,MAAO,YACPC,OAAQ,aACR3E,IAAK,MACL4E,IAAK,OAIDC,EAAW,CACfjE,OAAQ,SACRZ,IAAK,MACLC,kBAAmB,qBACnBC,QAAS,UACTC,KAAM,QAIF2E,EAAW,CACfC,KAAM,OACNC,OAAQ,SACRC,KAAM,QAIR,OACE,yBAAKvQ,UAAU,UACb,wBAAIA,UAAU,SAAd,mBACA,yBAAKA,UAAU,oBACb,yBAAKA,UAAU,uBACb,kBAAC,EAAD,CACE8J,OAAQxF,EACRuG,SAnDgB,SAAC2F,GACzBpB,EAAaoB,IAmDL/F,QAASwD,OAAOwC,KAAKX,GACrBlF,WAAYkF,EACZjG,YA5BoB,eA+BxB,yBAAK7J,UAAU,uBACb,kBAAC,EAAD,CACE8J,OAAQoB,EACRL,SAxDW,SAACK,GACpBmE,EAAQnE,IAwDAT,QAASwD,OAAOwC,KAAKN,GACrBvF,WAAYuF,EACZtG,YA5Bc,UA+BlB,yBAAK7J,UAAU,uBACb,kBAAC,EAAD,CACE8J,OAAQvF,EACRsG,SA7DY,SAACtG,GACrB+K,EAAS/K,IA6DDkG,QAASwD,OAAOwC,KAAKL,GACrBxF,WAAYwF,EACZvG,YA9Be,WAiCnB,yBAAK7J,UAAU,uBACb,4BACEA,UACEmG,EAAc,6BAA+B,eAE/CuK,QAASf,GAJX,aAOA,4BACE3P,WACGmG,EAAc,6BAA+B,gBAC9C,eAEFuK,QA5Ee,SAACrJ,GACnBlB,IACHkB,EAAEwI,iBACFzJ,OAoEI,aClEKuK,OArEf,WACE,IAAMC,EAAc,IAAIhP,MAAMrB,EAAKsB,MAAMC,KAAKvB,EAAK6D,YACnDwM,EAAYrQ,EAAKkH,eAAiBlH,EAAKU,SACvC2P,EAAYrQ,EAAKmH,aAAenH,EAAKa,OAHxB,MAKWkF,mBAASsK,GALpB,mBAKNtP,EALM,KAKAsC,EALA,OAMiC0C,mBAAS/F,EAAK6D,YAN/C,mBAMN2B,EANM,KAMWC,EANX,OAO6BM,mBAAS/F,EAAK6D,YAP3C,mBAON6B,EAPM,KAOSC,EAPT,OAQqBI,mBAAS,MAR9B,mBAQNhC,EARM,KAQK8K,EARL,OASW9I,mBAAS,MATpB,mBASN4E,EATM,KASAmE,EATA,OAUa/I,mBAAS,QAVtB,mBAUN/B,EAVM,KAUC+K,EAVD,OAWyBhJ,oBAAS,GAXlC,mBAWNH,EAXM,KAWO+I,EAXP,OAYyC5I,oBAAS,GAZlD,mBAYND,EAZM,KAYe8I,EAZf,OAaiB7I,mBAAS/F,EAAKkH,eAb/B,mBAaNR,EAbM,KAaGsI,EAbH,OAcajJ,mBAAS/F,EAAKmH,aAd3B,mBAcNR,EAdM,KAcCsI,EAdD,KAgBPpJ,EAAY,WAAgC,IAA/ByK,IAA8B,yDAC/C3O,QAAQC,IAAI,kBACZyB,EAAQgN,GACRzB,GAAuB,GACvBnJ,EAAmBzF,EAAK6D,YACxB8B,EAAiB3F,EAAK6D,YACtBmL,EAAWhP,EAAKkH,eAChB+H,EAASjP,EAAKmH,aACVmJ,IACFzB,EAAa,MACbC,EAAQ,MACRC,EAAS,QAIb,OACE,yBAAKtP,UAAU,QACb,kBAAC,GAAD,CACEsB,KAAMA,EACNsC,QAASA,EACTwC,UAAWA,EACX8I,eAAgBA,EAChBC,uBAAwBA,EACxB7K,UAAWA,EACX8K,aAAcA,EACdlE,KAAMA,EACNmE,QAASA,EACT9K,MAAOA,EACP+K,SAAUA,EACVnJ,YAAaA,EACboJ,WAAYA,EACZC,SAAUA,IAEZ,kBAAC,EAAKjP,KAAN,CACEe,KAAMA,EACNsC,QAASA,EACTmC,gBAAiBA,EACjBC,mBAAoBA,EACpBC,cAAeA,EACfC,iBAAkBA,EAClBE,UAAWA,EACXD,YAAaA,EACbE,oBAAqBA,EACrB/B,UAAWA,EACX2C,QAASA,EACTC,MAAOA,EACPqI,WAAYA,EACZC,SAAUA,MChElBsB,IAASC,OAAO,kBAAC,GAAD,CAAK/Q,UAAU,SAAWgR,SAASC,eAAe,W","file":"static/js/main.4687b570.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.f8a5f7dd.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.ff2b9671.svg\";","module.exports = __webpack_public_path__ + \"static/media/end.93326d55.svg\";","import React from 'react';\n// import Grid from './Grid.js';\nimport './../styles/Square.css';\nimport weight from './../images/weight.svg';\nimport start from './../images/start.svg';\nimport end from './../images/end.svg';\nimport Grid from './Grid';\n\nconst Square = (props) => {\n  return (\n    <div\n      id={props.id}\n      className={props.className}\n      onMouseDown={props.onMouseDown}\n      onMouseUp={props.onMouseUp}\n      onMouseOver={props.onMouseOver}\n      onKeyDown={props.onKeyDown}\n      onKeyUp={props.onKeyUp}\n      tabIndex={-1}>\n      {(props.className === Grid.WEIGHT_SQ ||\n        props.className === Grid.VISITED_WEIGHT_SQ ||\n        props.className === Grid.VISITED_FINISHED_WEIGHT_SQ ||\n        props.className === Grid.PATH_WEIGHT_SQ ||\n        props.className === Grid.PATH_FINISHED_WEIGHT_SQ) && (\n        <img\n          src={weight}\n          className='weightImg'\n          draggable='false'\n          alt='weight'\n        />\n      )}\n      {(props.className === Grid.START_SQ ||\n        props.className === Grid.PATH_HEAD_SQ) && (\n        <img src={start} className='startImg' draggable='false' alt='start' />\n      )}\n      {props.className === Grid.END_SQ && (\n        <img src={end} className='endImg' draggable='false' alt='end' />\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(Square);\n","import Grid from './../components/Grid';\n\nconst dijkstra = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(Grid.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const pq = [start];\n  while (pq.length > 0) {\n    console.log('running dijkstras');\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      let moveWeight = weights[currSquare];\n      // const elm = squareRefs[nextSquare].current;\n      // if (grid[nextSquare] === Grid.WALL_SQ) {\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === Grid.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (moveWeight < weights[pq[i]]) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst astar = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = new Array(Grid.SIZE).fill(Number.MAX_SAFE_INTEGER);\n  weights[start] = 1;\n\n  const heuristic = (start, end) => {\n    return (\n      Math.abs(Math.floor(start / Grid.WIDTH) - Math.floor(end / Grid.WIDTH)) +\n      Math.abs((start % Grid.WIDTH) - (end % Grid.WIDTH))\n    );\n  };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    console.log('running astar');\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      let moveWeight = weights[currSquare];\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === Grid.WEIGHT_SQ) {\n        moveWeight += 10;\n      } else {\n        moveWeight += 1;\n      }\n\n      if (moveWeight < weights[nextSquare]) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n\n        if (pq.includes(nextSquare)) {\n          pq.splice(pq.indexOf(nextSquare), 1);\n        }\n\n        // insert into priority queue\n        if (!visited.includes(nextSquare)) {\n          let inserted = false;\n          for (let i = 0; i < pq.length; i++) {\n            if (\n              moveWeight + heuristic(nextSquare, end) <\n              weights[pq[i]] + heuristic(pq[i], end)\n            ) {\n              pq.splice(i, 0, nextSquare);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) {\n            pq.push(nextSquare);\n          }\n        }\n      }\n    }\n  }\n\n  // retrace path\n  let path = [];\n  let currSquare = end;\n  while (currSquare) {\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n\n  return [visited, path];\n};\n\nconst greedy = (grid, setGrid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n  const weights = { start: 1 };\n\n  const pq = [start];\n  while (pq.length > 0) {\n    console.log('running greedy bfs');\n    const currSquare = pq.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      let moveWeight = Grid.dist(nextSquare, end);\n      // add weight for mountains and weights\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      } else if (grid[nextSquare] === Grid.WEIGHT_SQ) {\n        moveWeight += 10;\n      }\n\n      // insert into priority queue\n      if (!pq.includes(nextSquare) && !visited.includes(nextSquare)) {\n        weights[nextSquare] = moveWeight;\n        prev[nextSquare] = currSquare;\n        let inserted = false;\n        for (let i = 0; i < pq.length; i++) {\n          if (moveWeight < weights[pq[i]]) {\n            pq.splice(i, 0, nextSquare);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          pq.push(nextSquare);\n        }\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > Grid.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst dfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const stack = [start];\n  while (stack.length > 0) {\n    console.log('running dfs');\n    const currSquare = stack.pop();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // add weight for mountains and weights\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      }\n\n      // insert into stack\n      if (!visited.includes(nextSquare) && !stack.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        stack.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > Grid.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nconst bfs = (grid) => {\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n\n  const prev = {};\n  const visited = [];\n\n  const queue = [start];\n  while (queue.length > 0) {\n    console.log('running bfs');\n    const currSquare = queue.shift();\n    visited.push(currSquare);\n    if (currSquare === end) {\n      break;\n    }\n    const moves = [-1, 1, -Grid.WIDTH, Grid.WIDTH];\n    for (const nextSquare of moves\n      .map((move) => currSquare + move)\n      .filter((nextSquare) => Grid.validMove(currSquare, nextSquare))) {\n      // add weight for mountains and weights\n      if (grid[nextSquare] === Grid.WALL_SQ) {\n        continue;\n      }\n\n      // insert into queue\n      if (!visited.includes(nextSquare) && !queue.includes(nextSquare)) {\n        prev[nextSquare] = currSquare;\n        queue.push(nextSquare);\n      }\n    }\n  }\n\n  // retrace path\n  const path = [];\n  let currSquare = end;\n  let count = 0;\n  while (currSquare) {\n    if (count++ > Grid.SIZE) {\n      break;\n    }\n    path.unshift(currSquare);\n    currSquare = prev[currSquare];\n  }\n  return [visited, path];\n};\n\nexport default { dijkstra, astar, greedy, dfs, bfs };\n","import Grid from './../components/Grid';\nimport Algorithms from './Algorithms';\n\nconst clearAnimate = (grid, setGrid) => {\n  const nextGrid = grid.map((sq) => {\n    if (sq === Grid.START_SQ || sq === Grid.END_SQ || sq === Grid.WALL_SQ) {\n      return sq;\n    } else if (\n      sq === Grid.WEIGHT_SQ ||\n      sq === Grid.VISITED_WEIGHT_SQ ||\n      sq === Grid.VISITED_FINISHED_WEIGHT_SQ ||\n      sq === Grid.PATH_WEIGHT_SQ ||\n      sq === Grid.PATH_FINISHED_WEIGHT_SQ\n    ) {\n      return Grid.WEIGHT_SQ;\n    } else {\n      return Grid.DEFAULT_SQ;\n    }\n  });\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst animate = async (algorithm, grid, setGrid, speed, shouldDelay) => {\n  let pathDelay = 30;\n  let visitedDelay;\n  if (shouldDelay) {\n    switch (speed) {\n      case 'none':\n        break;\n      case 'slow':\n        visitedDelay = 100;\n        break;\n      case 'medium':\n        visitedDelay = 50;\n        break;\n      case 'fast':\n        visitedDelay = 0;\n        break;\n      default:\n        return Promise.resolve(false);\n    }\n  }\n  console.log('speed', speed);\n  let visited, path;\n  switch (algorithm) {\n    case 'dijkstra':\n      grid = clearAnimate(grid, setGrid);\n      [visited, path] = Algorithms.dijkstra(grid);\n      break;\n    case 'astar':\n      grid = clearAnimate(grid, setGrid);\n      [visited, path] = Algorithms.astar(grid);\n      break;\n    case 'greedy':\n      grid = clearAnimate(grid, setGrid);\n      [visited, path] = Algorithms.greedy(grid);\n      break;\n    case 'dfs':\n      grid = clearAnimate(grid, setGrid);\n      [visited, path] = Algorithms.dfs(grid);\n      break;\n    case 'bfs':\n      grid = clearAnimate(grid, setGrid);\n      [visited, path] = Algorithms.bfs(grid);\n      break;\n    default:\n      return Promise.resolve(false);\n  }\n\n  const start = grid.findIndex((sq) => sq === Grid.START_SQ);\n  const end = grid.findIndex((sq) => sq === Grid.END_SQ);\n  visited = visited.filter((square) => square !== start && square !== end);\n  path = path.filter((square) => square !== start && square !== end);\n\n  // animate visited\n  let prevSquare = null;\n  for (const square of visited) {\n    if (shouldDelay) {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === Grid.WEIGHT_SQ\n          ? Grid.VISITED_WEIGHT_SQ\n          : Grid.VISITED_SQ;\n      grid = changeSquare(grid, setGrid, square, Grid.VISITED_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n      await wait(visitedDelay);\n    } else {\n      const squareType =\n        grid[square] === Grid.WEIGHT_SQ\n          ? Grid.VISITED_FINISHED_WEIGHT_SQ\n          : Grid.VISITED_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n  if (shouldDelay) {\n    grid = changeSquare(grid, setGrid, prevSquare.ind, prevSquare.squareType);\n  }\n\n  // animate path\n  prevSquare = null;\n  for (const square of path) {\n    if (shouldDelay) {\n      if (prevSquare) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          prevSquare.ind,\n          prevSquare.squareType\n        );\n      }\n      const squareType =\n        grid[square] === Grid.VISITED_WEIGHT_SQ\n          ? Grid.PATH_WEIGHT_SQ\n          : Grid.PATH_SQ;\n      grid = changeSquare(grid, setGrid, square, Grid.PATH_HEAD_SQ);\n      prevSquare = { ind: square, squareType: squareType };\n      await wait(pathDelay);\n    } else {\n      const squareType =\n        grid[square] === Grid.VISITED_FINISHED_WEIGHT_SQ\n          ? Grid.PATH_FINISHED_WEIGHT_SQ\n          : Grid.PATH_FINISHED_SQ;\n      grid = changeSquare(grid, setGrid, square, squareType);\n    }\n  }\n  return Promise.resolve(false);\n};\n\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst changeSquare = (grid, setGrid, square, squareType) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nexport default { animate };\n","import React, { useState, useEffect } from 'react';\nimport './../styles/Grid.css';\nimport Square from './Square.js';\nimport Animations from './../services/Animations.js';\n\nconst WIDTH = 67;\nconst HEIGHT = 45;\nconst SIZE = WIDTH * HEIGHT;\nconst INITIAL_START = 22 * WIDTH + 6;\nconst INITIAL_END = 22 * WIDTH + 60;\nconst DEFAULT_SQ = 'square';\nconst START_SQ = 'startSquare';\nconst END_SQ = 'endSquare';\nconst WALL_SQ = 'wallSquare';\nconst WEIGHT_SQ = 'weightSquare';\nconst VISITED_SQ = 'visitedSquare';\nconst VISITED_WEIGHT_SQ = 'visitedWeightSquare';\nconst VISITED_HEAD_SQ = 'visitedHeadSquare';\nconst VISITED_FINISHED_SQ = 'visitedFinishedSquare';\nconst VISITED_FINISHED_WEIGHT_SQ = 'visitedFinishedWeightSquare';\nconst PATH_SQ = 'pathSquare';\nconst PATH_WEIGHT_SQ = 'pathWeightSquare';\nconst PATH_HEAD_SQ = 'pathHeadSquare';\nconst PATH_FINISHED_SQ = 'pathFinishedSquare';\nconst PATH_FINISHED_WEIGHT_SQ = 'pathFinishedWeightSquare';\n\nconst getRow = (sq) => {\n  return Math.floor(sq / WIDTH);\n};\n\nconst getCol = (sq) => {\n  return sq % WIDTH;\n};\n\nconst getCoor = (sq) => {\n  return [getRow(sq), getCol(sq)];\n};\n\nconst getSq = (row, col) => {\n  return row * WIDTH + col;\n};\n\nconst dist = (start, end) =>\n  Math.abs(getRow(start) - getRow(end)) + Math.abs(getCol(start) - getCol(end));\n\nconst validMove = (start, end) => {\n  return end < SIZE && end >= 0 && Math.abs(getCol(end) - getCol(start)) <= 2;\n};\n\nconst validMazeMove = (start, end) => {\n  const [endRow, endCol] = getCoor(end);\n  return (\n    endRow >= 1 &&\n    endRow < HEIGHT - 1 &&\n    endCol >= 1 &&\n    endCol < WIDTH - 1 &&\n    validMove(start, end)\n  );\n};\n\nconst Grid = ({\n  grid,\n  setGrid,\n  startIsCovering,\n  setStartIsCovering,\n  endIsCovering,\n  setEndIsCovering,\n  resetGrid,\n  isAnimating,\n  isAnimatingFinished,\n  algorithm,\n}) => {\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isHoldingStart, setIsHoldingStart] = useState(false);\n  const [isHoldingEnd, setIsHoldingEnd] = useState(false);\n  const [isWDown, setIsWDown] = useState(false);\n  const [mouseOver, setMouseOver] = useState(-1);\n\n  const startSq = grid.findIndex((sq) => sq === START_SQ);\n  const endSq = grid.findIndex((sq) => sq === END_SQ);\n\n  useEffect(() => {\n    if (isMouseDown && !isAnimating) {\n      const nextGrid = [...grid];\n      if (\n        isHoldingStart &&\n        mouseOver !== startSq &&\n        grid[mouseOver] !== END_SQ\n      ) {\n        nextGrid[startSq] = startIsCovering;\n        setStartIsCovering(grid[mouseOver]);\n        nextGrid[mouseOver] = START_SQ;\n        // setStartSq(mouseOver);\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none', false);\n          return;\n        }\n      } else if (\n        isHoldingEnd &&\n        mouseOver !== endSq &&\n        grid[mouseOver] !== START_SQ\n      ) {\n        nextGrid[endSq] = endIsCovering;\n        setEndIsCovering(grid[mouseOver]);\n        nextGrid[mouseOver] = END_SQ;\n        // setEndSq(mouseOver);\n        if (isAnimatingFinished) {\n          Animations.animate(algorithm, nextGrid, setGrid, 'none', false);\n          return;\n        }\n      } else if (isWDown && mouseOver !== startSq && mouseOver !== endSq) {\n        nextGrid[mouseOver] =\n          grid[mouseOver] === WEIGHT_SQ ? DEFAULT_SQ : WEIGHT_SQ;\n      } else if (mouseOver !== startSq && mouseOver !== endSq) {\n        nextGrid[mouseOver] =\n          grid[mouseOver] === WALL_SQ ? DEFAULT_SQ : WALL_SQ;\n      }\n      setGrid(nextGrid);\n    }\n  }, [isMouseDown, mouseOver]);\n\n  const onMouseUp = (id) => {\n    if (isHoldingStart) {\n      setIsHoldingStart(false);\n    } else if (isHoldingEnd) {\n      setIsHoldingEnd(false);\n    }\n    setIsMouseDown(false);\n  };\n\n  const onMouseDown = (id) => {\n    console.log('omd', startSq, endSq);\n    console.log('omd', grid[startSq]);\n    if (id === startSq) {\n      setIsHoldingStart(true);\n    } else if (id === endSq) {\n      setIsHoldingEnd(true);\n    }\n    setIsMouseDown(true);\n  };\n\n  const onMouseOver = (id) => {\n    setMouseOver(id);\n  };\n\n  const onKeyDown = (e) => {\n    if (e.key === 'w') {\n      setIsWDown(true);\n    }\n  };\n\n  const onKeyUp = (e) => {\n    if (e.key === 'w') {\n      setIsWDown(false);\n    }\n  };\n\n  const renderSquare = (sq, id) => {\n    return (\n      <Square\n        key={id}\n        id={id}\n        className={sq}\n        onMouseDown={() => onMouseDown(id)}\n        onMouseUp={() => onMouseUp(id)}\n        onMouseOver={() => onMouseOver(id)}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n      />\n    );\n  };\n\n  const renderGrid = (s, e) => {\n    return grid.map((sq, ind) => renderSquare(sq, ind));\n  };\n\n  return <div className='grid'>{renderGrid()}</div>;\n};\n\nexport default {\n  Grid,\n  WIDTH,\n  HEIGHT,\n  SIZE,\n  INITIAL_START,\n  INITIAL_END,\n  DEFAULT_SQ,\n  START_SQ,\n  END_SQ,\n  WALL_SQ,\n  WEIGHT_SQ,\n  VISITED_SQ,\n  VISITED_WEIGHT_SQ,\n  VISITED_HEAD_SQ,\n  VISITED_FINISHED_SQ,\n  VISITED_FINISHED_WEIGHT_SQ,\n  PATH_SQ,\n  PATH_WEIGHT_SQ,\n  PATH_HEAD_SQ,\n  PATH_FINISHED_SQ,\n  PATH_FINISHED_WEIGHT_SQ,\n  getRow,\n  getCol,\n  getCoor,\n  getSq,\n  dist,\n  validMove,\n  validMazeMove,\n};\n","import React from 'react';\nimport ReactSelect from 'react-select';\nimport './../styles/TopBar.css';\n\nconst Select = (props) => {\n  const customSelectStyle = {\n    menu: (provided, state) => ({\n      ...provided,\n      backgroundColor: 'rgb(17, 138, 178)',\n      width: '160px',\n      border: 'none',\n      margin: '0px',\n      padding: '0px',\n    }),\n    menuList: (provided, state) => ({\n      ...provided,\n      padding: '0px',\n      borderRadius: '0px 0px 5px 5px',\n    }),\n    container: (provided, state) => ({\n      ...provided,\n      height: '40px',\n      margin: 'auto 10px',\n      display: 'flex',\n      alignItems: 'center',\n    }),\n    control: (provided, state) => ({\n      ...provided,\n      width: '160px',\n      height: '100%',\n      border: 'none',\n      borderRadius: state.menuIsOpen ? '5px 5px 0px 0px' : '5px',\n      boxShadow: 'none',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n      fontSize: '20px',\n      cursor: 'pointer',\n      userSelect: 'none',\n\n      color: 'white',\n      backgroundColor:\n        state.hasValue || state.menuIsOpen\n          ? 'rgb(17, 138, 178)'\n          : 'transparent',\n      '&:hover': {\n        backgroundColor: 'rgb(17, 138, 178)',\n        color: 'white',\n        border: 'none',\n      },\n    }),\n    dropdownIndicator: (provided, state) => ({\n      margin: '3px',\n    }),\n    indicatorSeparator: (provided) => ({}),\n    placeholder: (provided, state) => ({}),\n    option: (provided, state) => ({\n      ...provided,\n      cursor: 'pointer',\n      fontFamily: 'Roboto, sans-serif',\n      fontWeight: 300,\n\n      color: 'white',\n      backgroundColor: 'rgb(17, 138, 178)',\n      '&:hover': {\n        color: 'rgb(38, 70, 83)',\n        backgroundColor: 'rgb(233, 196, 106)',\n      },\n    }),\n    singleValue: (provided) => ({\n      ...provided,\n      whiteSpace: 'nowrap',\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      paddingRight: '4px',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n      lineHeight: '36px',\n      top: '50%',\n      color: '',\n    }),\n    valueContainer: (provided) => ({\n      ...provided,\n      height: '100%',\n    }),\n  };\n\n  return (\n    <ReactSelect\n      styles={customSelectStyle}\n      options={props.options.map((option) => ({\n        value: option,\n        label: props.optionsMap[option],\n      }))}\n      value={\n        props.option && {\n          value: props.option,\n          label: props.optionsMap[props.option],\n        }\n      }\n      onChange={(data) => props.onChange(data.value)}\n      placeholder={props.placeholder}\n      isSearchable={false}\n      tabSelectsValue={false}\n    />\n  );\n};\n\nexport default Select;\n","import Grid from '../components/Grid';\n\nconst generateMaze = async (maze, grid, setGrid, resetGrid, speed) => {\n  if (!maze) {\n    return Promise.resolve({ finished: false, grid: grid });\n  }\n  grid = new Array(Grid.SIZE).fill(Grid.DEFAULT_SQ);\n  setGrid(grid);\n  console.log('performing maze', maze);\n  let delay = 1;\n\n  switch (maze) {\n    case 'random':\n      return await randomMaze(grid, setGrid, delay);\n    case 'dfs':\n      return await dfs(grid, setGrid, delay);\n    case 'recursiveDivision':\n      return await recursiveDivision(grid, setGrid, delay);\n    case 'kruskal':\n      return await kruskal(grid, setGrid, delay);\n    case 'prim':\n      return await prim(grid, setGrid, delay);\n    default:\n  }\n};\n\nconst changeSquare = (grid, setGrid, square, squareType) => {\n  const nextGrid = [...grid];\n  nextGrid[square] = squareType;\n  setGrid(nextGrid);\n  return nextGrid;\n};\n\nconst wait = (ms) =>\n  ms ? new Promise((resolve) => setTimeout(resolve, ms)) : ms;\n\nconst drawRow = async (grid, setGrid, delay, row, colRange) => {\n  for (let i = colRange[0]; i <= colRange[1]; i++) {\n    const sq = row * Grid.WIDTH + i;\n    grid = changeSquare(grid, setGrid, sq, Grid.WALL_SQ);\n    await wait(delay);\n  }\n  return Promise.resolve(grid);\n};\n\nconst drawCol = async (grid, setGrid, delay, col, rowRange) => {\n  for (let i = rowRange[0]; i <= rowRange[1]; i++) {\n    const sq = i * Grid.WIDTH + col;\n    grid = changeSquare(grid, setGrid, sq, Grid.WALL_SQ);\n    await wait(delay);\n  }\n  return Promise.resolve(grid);\n};\n\nconst drawMazeBorder = async (grid, setGrid, delay) => {\n  for (let i = 0; i < Grid.WIDTH; i++) {\n    grid = changeSquare(grid, setGrid, Grid.getSq(0, i), Grid.WALL_SQ);\n    grid = changeSquare(\n      grid,\n      setGrid,\n      Grid.getSq(Grid.HEIGHT - 1, i),\n      Grid.WALL_SQ\n    );\n    // await wait(delay);\n  }\n  for (let i = 1; i < Grid.HEIGHT - 1; i++) {\n    grid = changeSquare(grid, setGrid, Grid.getSq(i, 0), Grid.WALL_SQ);\n    grid = changeSquare(\n      grid,\n      setGrid,\n      Grid.getSq(i, Grid.WIDTH - 1),\n      Grid.WALL_SQ\n    );\n    // await wait(delay);\n  }\n  return Promise.resolve(grid);\n};\n\nconst generateWallGrid = (grid, setGrid) => {\n  for (let row = 0; row < Grid.HEIGHT; row++) {\n    for (let col = 0; col < Grid.WIDTH; col++) {\n      if (row % 2 && col % 2) {\n        grid = changeSquare(\n          grid,\n          setGrid,\n          Grid.getSq(row, col),\n          Grid.DEFAULT_SQ\n        );\n      } else {\n        grid = changeSquare(grid, setGrid, Grid.getSq(row, col), Grid.WALL_SQ);\n      }\n    }\n  }\n  return grid;\n};\n\nconst getRandomNumberBetween = (start, end) => {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n};\n\nconst getRandomElement = (array) => {\n  return array.splice(getRandomNumberBetween(0, array.length - 1), 1)[0];\n};\n\nconst shuffleArray = (array) => {\n  const newArray = [];\n  while (array.length > 0) {\n    newArray.push(getRandomElement(array));\n  }\n  return newArray;\n};\n\nconst getClosestEmptyTileFrom = (grid, from) => {\n  return grid.reduce((closest, sq, idx) => {\n    if (sq === Grid.DEFAULT_SQ) {\n      if (closest === -1) {\n        return idx;\n      } else {\n        const closestDist = Grid.dist(from, closest);\n        const sqDist = Grid.dist(from, idx);\n        return sqDist < closestDist ? idx : closest;\n      }\n    } else {\n      return closest;\n    }\n  }, -1);\n};\n\nconst generateStartEndPosition = (grid, setGrid, idealStart, idealEnd) => {\n  const start = getClosestEmptyTileFrom(grid, idealStart);\n  const end = getClosestEmptyTileFrom(grid, idealEnd);\n  grid = changeSquare(grid, setGrid, start, Grid.START_SQ);\n  return changeSquare(grid, setGrid, end, Grid.END_SQ);\n};\n\nconst randomMaze = async (grid, setGrid, delay) => {\n  grid = await drawMazeBorder(grid, setGrid, delay);\n  for (let i = 0; i < grid.length; i++) {\n    if (Grid.validMazeMove(i, i) && Math.random() < 0.35) {\n      // grid = changeSquare(grid, setGrid, i, Grid.WALL_SQ);\n      grid[i] = Grid.WALL_SQ;\n    }\n  }\n  setGrid(grid);\n  await wait(delay);\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(0, 0),\n    Grid.getSq(Grid.SIZE - 1, Grid.SIZE - 1)\n  );\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst dfs = async (grid, setGrid, delay) => {\n  grid = generateWallGrid(grid, setGrid, delay);\n  const start = Grid.getSq(1, 1);\n  const visited = new Set([start]);\n  const path = [start];\n  while (path.length > 0) {\n    const currSquare = path.pop();\n    let moves = [-2, 2, -2 * Grid.WIDTH, 2 * Grid.WIDTH];\n    moves = moves.filter((move) =>\n      Grid.validMazeMove(currSquare, currSquare + move)\n    );\n\n    while (moves.length > 0) {\n      const nextMove =\n        currSquare + moves.splice(Math.random() * moves.length, 1)[0];\n      const nextMoves = [(currSquare + nextMove) / 2, nextMove];\n      if (!visited.has(nextMove)) {\n        grid = changeSquare(grid, setGrid, nextMoves[0], Grid.DEFAULT_SQ);\n        await wait(delay);\n        grid = changeSquare(grid, setGrid, nextMoves[1], Grid.DEFAULT_SQ);\n        await wait(delay);\n        visited.add(nextMove);\n        path.push(nextMove);\n        path.push(nextMove);\n        break;\n      }\n    }\n  }\n\n  // place end as far away as possible from start\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.SIZE - 1, Grid.SIZE - 1)\n  );\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst recursiveDivision = async (grid, setGrid, delay) => {\n  grid = await drawMazeBorder(grid, setGrid, delay);\n  grid = await divide(\n    grid,\n    setGrid,\n    delay,\n    [0, Grid.HEIGHT - 1],\n    [0, Grid.WIDTH - 1]\n  );\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.HEIGHT - 1, Grid.WIDTH - 1)\n  );\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst divide = async (grid, setGrid, delay, rowRange, colRange) => {\n  const [possibleRows, possibleRowHoles] = [[], []];\n  const [possibleCols, possibleColHoles] = [[], []];\n  for (let i = rowRange[0] + 1; i < rowRange[1]; i++) {\n    if ((i - rowRange[0]) % 2 === 0) {\n      possibleRows.push(i);\n    } else {\n      possibleRowHoles.push(i);\n    }\n  }\n  for (let i = colRange[0] + 1; i < colRange[1]; i++) {\n    if ((i - colRange[0]) % 2 === 0) {\n      possibleCols.push(i);\n    } else {\n      possibleColHoles.push(i);\n    }\n  }\n\n  if (possibleRows.length === 0 || possibleCols.length === 0) {\n    return Promise.resolve(grid);\n  } else {\n    if (possibleRows.length >= possibleCols.length) {\n      const randomRow = getRandomElement(possibleRows);\n      grid = await drawRow(grid, setGrid, delay, randomRow, colRange);\n      const randomColHole = getRandomElement(possibleColHoles);\n      const randomHole = randomRow * Grid.WIDTH + randomColHole;\n      grid = changeSquare(grid, setGrid, randomHole, Grid.DEFAULT_SQ);\n      await wait(delay);\n      grid = await divide(\n        grid,\n        setGrid,\n        delay,\n        [rowRange[0], randomRow],\n        colRange\n      );\n      grid = await divide(\n        grid,\n        setGrid,\n        delay,\n        [randomRow, rowRange[1]],\n        colRange\n      );\n    } else {\n      let randomCol = getRandomElement(possibleCols);\n      grid = await drawCol(grid, setGrid, delay, randomCol, rowRange);\n      const randomRowHole = getRandomElement(possibleRowHoles);\n      const randomHole = randomRowHole * Grid.WIDTH + randomCol;\n      grid = await changeSquare(grid, setGrid, randomHole, Grid.DEFAULT_SQ);\n      grid = await divide(grid, setGrid, delay, rowRange, [\n        colRange[0],\n        randomCol,\n      ]);\n      grid = await divide(grid, setGrid, delay, rowRange, [\n        randomCol,\n        colRange[1],\n      ]);\n    }\n    return Promise.resolve(grid);\n  }\n};\n\nconst kruskal = async (grid, setGrid, delay) => {\n  grid = generateWallGrid(grid, setGrid, delay);\n  let treeSet = {};\n  let wallMap = {};\n  // fill wallMap and treeSet\n  for (let i = 0; i < Grid.SIZE; i++) {\n    const [iRow, iCol] = Grid.getCoor(i);\n    if (Grid.validMazeMove(i, i)) {\n      if (iRow % 2 && iCol % 2) {\n        treeSet[i] = new Set([i]);\n      } else {\n        if (iCol % 2) {\n          wallMap[i] = [i - Grid.WIDTH, i + Grid.WIDTH];\n        } else if (iRow % 2) {\n          wallMap[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  for (const [wall, [sq1, sq2]] of shuffleArray(Object.entries(wallMap))) {\n    if (!treeSet[sq1].has(sq2)) {\n      grid = changeSquare(grid, setGrid, wall, Grid.DEFAULT_SQ);\n      await wait(delay);\n      const union = new Set([...treeSet[sq1], ...treeSet[sq2]]);\n      treeSet[sq1].forEach((sq) => (treeSet[sq] = union));\n      treeSet[sq2].forEach((sq) => (treeSet[sq] = union));\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.HEIGHT - 1, Grid.WIDTH - 1)\n  );\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nconst prim = async (grid, setGrid, delay) => {\n  grid = generateWallGrid(grid, setGrid, delay);\n  let neighborSquares = {};\n  let neighborWalls = {};\n  // fill walls\n  for (let i = 0; i < Grid.SIZE; i++) {\n    if (Grid.validMazeMove(i, i)) {\n      const [iRow, iCol] = Grid.getCoor(i);\n      if (iRow % 2 && iCol % 2) {\n        const t = Grid.validMazeMove(i, i - Grid.WIDTH) ? [i - Grid.WIDTH] : [];\n        const r = Grid.validMazeMove(i, i + 1) ? [i + 1] : [];\n        const b = Grid.validMazeMove(i, i + Grid.WIDTH) ? [i + Grid.WIDTH] : [];\n        const l = Grid.validMazeMove(i, i - 1) ? [i - 1] : [];\n        neighborWalls[i] = [...t, ...r, ...b, ...l];\n      } else if (iRow % 2 ^ iCol % 2) {\n        if (iCol % 2) {\n          neighborSquares[i] = [i - Grid.WIDTH, i + Grid.WIDTH];\n        } else if (iRow % 2) {\n          neighborSquares[i] = [i - 1, i + 1];\n        }\n      }\n    }\n  }\n\n  const visitedSquares = new Set([Grid.getSq(1, 1)]);\n  let visitedWalls = [...neighborWalls[Grid.getSq(1, 1)]];\n  while (visitedWalls.length > 0) {\n    const randomWall = getRandomElement(visitedWalls);\n    const [sq1, sq2] = neighborSquares[randomWall];\n    if (sq1 > Grid.SIZE || sq2 > Grid.SIZE) {\n    }\n    if (visitedSquares.has(sq1) ^ visitedSquares.has(sq2)) {\n      if (!visitedSquares.has(sq1)) {\n        visitedSquares.add(sq1);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq1]];\n      } else {\n        visitedSquares.add(sq2);\n        visitedWalls = [...visitedWalls, ...neighborWalls[sq2]];\n      }\n      grid = changeSquare(grid, setGrid, randomWall, Grid.DEFAULT_SQ);\n      await wait(delay);\n    }\n  }\n\n  grid = generateStartEndPosition(\n    grid,\n    setGrid,\n    Grid.getSq(1, 1),\n    Grid.getSq(Grid.HEIGHT - 1, Grid.WIDTH - 1)\n  );\n  return Promise.resolve({ finished: false, grid: grid });\n};\n\nexport default { generateMaze };\n","import React, { useEffect } from 'react';\nimport Select from './Select';\nimport './../styles/TopBar.css';\nimport Animations from './../services/Animations.js';\nimport Maze from './../services/Maze.js';\nimport Grid from './Grid';\n\nconst TopBar = (props) => {\n  const {\n    grid,\n    setGrid,\n    resetGrid,\n    setIsAnimating,\n    setIsAnimatingFinished,\n    algorithm,\n    setAlgorithm,\n    maze,\n    setMaze,\n    speed,\n    setSpeed,\n    isAnimating,\n    setStartSq,\n    setEndSq,\n  } = props;\n\n  useEffect(() => {\n    (async () => {\n      if (!isAnimating) {\n        setIsAnimating(true);\n        const promise = await Maze.generateMaze(maze, grid, setGrid, resetGrid);\n        setIsAnimating(promise.finished);\n        const start = promise.grid.findIndex((sq) => sq === Grid.START_SQ);\n        const end = promise.grid.findIndex((sq) => sq === Grid.END_SQ);\n        console.log(start, end);\n        setStartSq(start);\n        setEndSq(end);\n        setIsAnimatingFinished(false);\n      }\n    })();\n  }, [maze]);\n\n  const handleAlgorithmSubmit = async (event) => {\n    event.preventDefault();\n    if (!isAnimating) {\n      setIsAnimating(true);\n      const isAnimating = await Animations.animate(\n        algorithm,\n        grid,\n        setGrid,\n        speed,\n        true\n      );\n      setIsAnimating(isAnimating);\n      setIsAnimatingFinished(!isAnimating);\n    }\n  };\n\n  const onAlgorithmChange = (alg) => {\n    setAlgorithm(alg);\n  };\n\n  const onMazeChange = (maze) => {\n    setMaze(maze);\n  };\n\n  const onSpeedChange = (speed) => {\n    setSpeed(speed);\n  };\n\n  const handleResetClick = (e) => {\n    if (!isAnimating) {\n      e.preventDefault();\n      resetGrid();\n    }\n  };\n\n  const algorithmsMap = {\n    dijkstra: 'Dijkstra',\n    astar: 'A* Search',\n    greedy: 'Greedy BFS',\n    dfs: 'DFS',\n    bfs: 'BFS',\n  };\n  const algorithmsPlaceholder = 'Algorithm';\n\n  const mazesMap = {\n    random: 'Random',\n    dfs: 'DFS',\n    recursiveDivision: 'Recursive Division',\n    kruskal: 'Kruskal',\n    prim: 'Prim',\n  };\n  const mazePlaceholder = 'Maze';\n\n  const speedMap = {\n    slow: 'Slow',\n    medium: 'Medium',\n    fast: 'Fast',\n  };\n  const speedPlaceholder = 'Speed';\n\n  return (\n    <div className='topBar'>\n      <h1 className='title'>Path Visualizer</h1>\n      <div className='optionsContainer'>\n        <div className='topBarItemContainer'>\n          <Select\n            option={algorithm}\n            onChange={onAlgorithmChange}\n            options={Object.keys(algorithmsMap)}\n            optionsMap={algorithmsMap}\n            placeholder={algorithmsPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={maze}\n            onChange={onMazeChange}\n            options={Object.keys(mazesMap)}\n            optionsMap={mazesMap}\n            placeholder={mazePlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <Select\n            option={speed}\n            onChange={onSpeedChange}\n            options={Object.keys(speedMap)}\n            optionsMap={speedMap}\n            placeholder={speedPlaceholder}\n          />\n        </div>\n        <div className='topBarItemContainer'>\n          <button\n            className={\n              isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton'\n            }\n            onClick={handleAlgorithmSubmit}>\n            Visualize\n          </button>\n          <button\n            className={\n              (isAnimating ? 'topBarButtonWhileAnimating' : 'topBarButton') +\n              ' resetButton'\n            }\n            onClick={handleResetClick}>\n            Reset\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TopBar;\n","import React, { useState } from 'react';\nimport './../styles/App.css';\nimport Grid from './Grid.js';\nimport TopBar from './TopBar.js';\n\nfunction App() {\n  const initialGrid = new Array(Grid.SIZE).fill(Grid.DEFAULT_SQ);\n  initialGrid[Grid.INITIAL_START] = Grid.START_SQ;\n  initialGrid[Grid.INITIAL_END] = Grid.END_SQ;\n\n  const [grid, setGrid] = useState(initialGrid);\n  const [startIsCovering, setStartIsCovering] = useState(Grid.DEFAULT_SQ);\n  const [endIsCovering, setEndIsCovering] = useState(Grid.DEFAULT_SQ);\n  const [algorithm, setAlgorithm] = useState(null);\n  const [maze, setMaze] = useState(null);\n  const [speed, setSpeed] = useState('fast');\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isAnimatingFinished, setIsAnimatingFinished] = useState(false);\n  const [startSq, setStartSq] = useState(Grid.INITIAL_START);\n  const [endSq, setEndSq] = useState(Grid.INITIAL_END);\n\n  const resetGrid = (shouldResetSelects = true) => {\n    console.log('resetting grid');\n    setGrid(initialGrid);\n    setIsAnimatingFinished(false);\n    setStartIsCovering(Grid.DEFAULT_SQ);\n    setEndIsCovering(Grid.DEFAULT_SQ);\n    setStartSq(Grid.INITIAL_START);\n    setEndSq(Grid.INITIAL_END);\n    if (shouldResetSelects) {\n      setAlgorithm(null);\n      setMaze(null);\n      setSpeed(null);\n    }\n  };\n\n  return (\n    <div className='page'>\n      <TopBar\n        grid={grid}\n        setGrid={setGrid}\n        resetGrid={resetGrid}\n        setIsAnimating={setIsAnimating}\n        setIsAnimatingFinished={setIsAnimatingFinished}\n        algorithm={algorithm}\n        setAlgorithm={setAlgorithm}\n        maze={maze}\n        setMaze={setMaze}\n        speed={speed}\n        setSpeed={setSpeed}\n        isAnimating={isAnimating}\n        setStartSq={setStartSq}\n        setEndSq={setEndSq}\n      />\n      <Grid.Grid\n        grid={grid}\n        setGrid={setGrid}\n        startIsCovering={startIsCovering}\n        setStartIsCovering={setStartIsCovering}\n        endIsCovering={endIsCovering}\n        setEndIsCovering={setEndIsCovering}\n        resetGrid={resetGrid}\n        isAnimating={isAnimating}\n        isAnimatingFinished={isAnimatingFinished}\n        algorithm={algorithm}\n        startSq={startSq}\n        endSq={endSq}\n        setStartSq={setStartSq}\n        setEndSq={setEndSq}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App className='page' />, document.getElementById('root'));\n"],"sourceRoot":""}